
/*!
    @mainpage A Consumer Library Interface to DWARF
    @author David Anderson
    @date 2022-01-21 
 
    @section draft THIS IS A DRAFT

    THIS DOCUMENT IS AN EARLY AND INCOMPLETE DRAFT!
    SUGGESTIONS FOR IMPROVEMENT ARE WELCOME.

    @section dw_intro Introduction


    This document describes an interface to @e libdwarf, a library of
    functions to provide access to DWARF debugging information
    records,
    DWARF line number information, DWARF address range and global
    names information, weak names information, DWARF frame
    description
    information, DWARF static function names, DWARF static variables,
    and DWARF type information.
 
    The document has long mentioned the "Unix International
    Programming
    Languages Special Interest Group" (PLSIG), under whose
    auspices the
    DWARF committee was formed around 1991. "Unix International" was
    disbanded in the 1990s and no longer exists.
 
    The DWARF committee published DWARF2 July 27, 1993.
 
    In the mid 1990s this document and the library it describes
    (which
    the committee never endorsed, having decided not to endorse or
    approve any particular library interface)
    was made available on the
    internet by Silicon Graphics, Inc.
 
    In 2005 the DWARF committee began an affiliation with
    FreeStandards.org. In 2007 FreeStandards.org merged with The Linux
    Foundation. The DWARF committee dropped its affiliation with
    FreeStandards.org in 2007 and established the dwarfstd.org
    website. See "http://www.dwarfstd.org" for current information on
    standardization activities and a copy of the standard.

    @section dw_threadsafety Thread Safety

    Libdwarf can safely open multiple Dwarf_Debug
    pointers simultaneously but all such Dwarf_Debug
    pointers must be opened within the same thread.
    And all libdwarf calls must be made from within
    that single (same) thread.
 
    @section dw_error Error Handling in libdwarf
    Essentially every libdwarf call could involve dealing
    with an error (possibly data corruption in
    the object file).  Here we explain the two main
    approaces the library provides (though we think
    only one of them is truly appropriate except
    in toy programs).

    A) The suggested approach is to  define a Dwarf_Error
    @code
    Dwarf_Error error = 0;
    @endcode
    Then, in ever call where there is a Dwarf_Error argument
    pass its address
    @code
    int res = dwarf_tag(die,DW_TAG_compile_unit,&error);
    @endcode

    The possible return values to res are, in general:
    @code
    DW_DLV_OK
    DW_DLV_NO_ENTRY
    DW_DLV_ERROR
    @endcode
  
    If DW_DLV_ERROR is returned then error is set
    (by the library) to a pointer to important
    details about the
    error.  If DW_DLV_NO_ENTRY or DW_DLV_OK is
    returned the error argument is ignored by the library.

    Some functions cannot possibly return some of these
    three values. As defined later for each function.

    With this approach the 

    B) An alternative (not recommended) approach is
    to simply pass NULL to the error argument.
    @code
    int res = dwarf_tag(die,DW_TAG_compile_unit,NULL);
    @endcode

    If your initialization provided an 'errhand'
    function pointer argument (see below) the
    library will call errhand if an error is encountered.
    (Your errhand function could simply exit if you so choose.)

    The the library will then return DW_DLV_ERROR, though
    you will have no way to identify what the error was.
    Could be a malloc fail or data corruption or an
    invalid argument to the call, or something else.

    That is the whole picture. The library never
    calls exit() under any circumstances.

    
    @subsection dw_errorinit Error Handling at initialization

    Each initialization call (for example)
    @code
    dwarf_init_path(args...)
    @endcode
    has two arguments that appear nowhere
    else in the library.
    @code
    Dwarf_Handler dw_errhand
    Dwarf_Ptr dw_errarg
    @endcode

    If you use the suggested A) approach
    just pass NULL to both those arguments.

    Note that dw_errarg is a pointer so one could
    create a struct with data of interest and use
    that pointer as the dw_errarg.
    Or one could put an integer in there or simply NULL,
    it just depends what you want to do in the
    Dwarf_Handler function you write.

    If you wish to provide a dw_errhand, define a function
    (this first example is not a good choice)
    @code
    void bad_dw_errhandler(Dwarf_Error error,Dwarf_Ptr ptr)
    {
        printf("ERROR Exit on %lx due to error 0x%lx %s\n",
            (unsigned long)ptr,
            (unsigned long)dwarf_errno(error),
            dwarf_errmsg(error));
        exit(1)
    } 
    @endcode
    and pass bad_dw_errhandler (as a function pointer,
    no parentheses 
    The Dwarf_Ptr argument is the value you passed in as dw_errarg,
    and can be anything.
    By doing an exit() you guarantee that your application
    abruptly stops.  This is only acceptible to toy
    or practice programs.

    A better dw_errhand function is
    @code
    void my_dw_errhandler(Dwarf_Error error,Dwarf_Ptr ptr)
    {
        /*  Clearly one could write to a log file or do
            whatever the application finds useful. */
        printf("ERROR on %lx due to error 0x%lx %s\n",
            (unsigned long)ptr,
            (unsigned long)dwarf_errno(error),
            dwarf_errmsg(error));
    } 
    @endcode
    because it returns.  The DW_DLV_ERROR code
    is returned from libdwarf and your code
    can do what it likes with the error situation.
    

    @code
    Dwarf_Ptr x = address of some struct I want in the errhandler;
    res = dwarf_init_path(...,my_dw_errhandler,x,... );
    if (res == ...)
    @endcode
    If you do not wish to provide a dw_errhand, just pass
    both arguments as NULL.

    @subsection dw_errorcall Error Handling Everywhere

    So let us examine a case where anything could happen.
    And here we are taking the recommeded  method
    of using a non-null dwarf_Error*:

    @code
    int func(Dwarf_Dbg dbg,Dwarf_Die die, Dwarf_Error* error) {
        res = dwarf_sibingof_b(die,&newdie,error);
    ...
    }
    @endcode

    If res == DW_DLV_OK, then newdie is a DIE pointer
    and when appropriate we should do dwarf_dealloc_die(newdie)
    
    If res == DW_DLV_NO_ENTRY, then newdie is not set
    and there is no error. In this case it means
    die was the last of a siblinglist. The exact meaning
    of course depends on the call.

    If res == DW_DLV_ERROR then something really bad
    happened. The only way to know what is to examine
    the *error as in
    @code
    int ev = dwarf_errno(*error);
    or
    char * msg  = dwarf_errmsg(*error);
    or both and report that somehow.
    @endcode
    
    If it's a decently large program then
    you want to free any local memory
    and return res. If a small and unimportant
    program print something and exit.

    If you want to discard the error report then
    @code
        dwarf_dealloc_error(dbg,*error);
        *error = 0;
        return DW_DLV_OK;
        /* or DW_DLV_NO_ENTRY */
    @endcode

    That's all there is to it.
 

    @subsection linetableregisters Line Table Registers

    Line Table Registers

    Please refer to the DWARF5 Standard for details.
    The line table registers are named in Section
    6.2.2 State Machine Registers and are
    not much changed from DWARF2.

    Certain functions on Dwarf_Line data
    return values for these 'registers'
    as these are the data available for
    debuggers and other tools  to relate
    code addresses to source file locations.

    @code
    address
    op_index
    file
    line
    column
    is_stmt
    basic_block
    end_sequence
    prologue_end
    epilogue_begin
    isa
    discriminator
    @endcode

    @subsection independentsections Reading Special Sections Independently

    Reading a particular set of special sections

    DWARF defines (in each version of DWARF)
    sections which have a somewhat special
    character.  
    These are referenced from compilation units
    and other places and the Standard does not
    forbid blocks of random bytes at the start or end
    or between the areas
    referenced from elsewhere.

    Sometimes compilers (or linkers) leave trash
    behind as a result of optimizations.
    If there is a lot of space wasted that way it is
    quality of implementation issue.
    But usually the wasted space, if any, is small.

    Compiler writers or others may be interested in looking
    at these sections indepently so libdwarf provides
    functions
    that allow reading the sections without reference
    to what references them.  

    @link abbrev Abbreviations can be read independently @endlink

    @link string Strings can be read independently @endlink

    @link str_offsets String Offsets can be read independently @endlink

    Those functions allow starting at byte 0 of the section
    and provide a length so you can calulate the next
    section offset to call or refer to.

    Usually that works fine.
    But if there is some random data somewhere
    outside of referenced areas the reader function
    may fail, reteurning DW_DLV_ERROR. 
    Such an error is neither a compiler bug nor a libdwarf bug.

    @subsection frameregs Special Frame Registers

    In dealing with .debug_frame or .eh_frame
    there are a few related values that must be set
    unless one has relatively few registers in the
    target ABI (anything under 188 registers, see
    dwarf.h DW_FRAME_LAST_REG_NUM for this default).

    The requirements stem from the design of the section.
    See the DWARF5 Standard for details.

    Keep in mind that register values correspond
    to columns in the theoretical fully complete
    table of a row per pc and a column per register.

    There is no time or space penalty in setting
    Undefined_Value, Same_Value, and  CFA_Column
    much larger than the Table_Size.

    Here are the five values.

    @b Table_Size: This sets the number of columns
        in the theoretical table.  It starts at 
        DW_FRAME_LAST_REG_NUM which defaults to 188. 
        This is the only value you
        might need to change, given the defaults
        of the others are set reasonably large by
        default.

    @b Undefined_Value: A register number that means
       the register value is undefined. For example due
       to a call clobbering the register.
       DW_FRAME_UNDEFINED_VAL defaults to  12288.
       There no such column in the table.

    @b Same_Value: A register number that means
        the register value is the same as the value
        at the call. Nothing can have clobbered it.
        DW_FRAME_SAME_VAL defaults to 12289.
        There no such column in the table.

    @b Initial_Value:    The value must be either
        DW_FRAME_UNDEFINED_VAL or DW_FRAME_SAME_VAL to represent
        how most registers are to be thought of at a function call.
        This is a property of the ABI and instruction set.
        Specific frame instructions in the CIE or FDE
        will override this for registers not matching
        this value.

    @b CFA_Column:       A number for the CFA.
        Defined so we can use a register number
        to refer to it.
        DW_FRAME_CFA_COL defaults to 12290.
        There no such column in the table.
        See libdwarf.h struct member rt3_cfa_rule
        or function dwarf_get_fde_info_for_cfa_reg3_b .

    A set of functions allow these to be changed
    at runtime. The set should be called (if
    needed) immediately after initializing a Dwarf_Debug
    and before any other calls on that Dwarf_Debug.
    If just one value (for exampole, Table_Size)
    needs altering, then just call that single function.

    For the library accessing frame data to work properly
    there are certain invariants that must be
    true once the set of functions have been called.

    REQUIRED:
    @code
       Table_Size      > the number of registers in the ABI.
       Undefined_Value != Same_Value
       CFA_Column      != Undefined_value
       CFA_Column      != Same_value
       Initial_Value   == Same_Value ||
           (Initial_Value == Undefined_value)
       Undefined_Value > Table_Size
       Same_Value      > Table_Size
       CFA_Column      > Table_Size
    @endcode

    @section dw_pubnames .debug_pubnames etc DWARF2-DWARF4 

    Each section consists of a header for a specific 
    compilation unit (CU) followed by an a set of tuples,
    each tuple consisting of an offset of a compilation unit
    followed by a null-terminated namestring. The tuple set is ended
    by a 0,0 pair. Then followed with the data for the next
    CU and so on.

    The function set provided for each such section
    allows one to print all the section data as it literally
    appears in the section (with headers and
    tuples) or to treat it as a single array with CU data
    columns.

    Each has a set of 6 functions. 
  
    @code
     Section         typename      Standard      main function
    .debug_pubnames  Dwarf_Global  DWARF2-DWARF4 dwarf_get_globals
    .debug_pubtypes  Dwarf_Type    DWARF3,DWARF4 dwarf_get_pubtypes
    @endcode

    The following four were defined in SGI/IRIX compilers
    in the 1990s but never part of the DWARF standard.
    
    It not likely you will encounter these.

    @code
    .debug_funcs      Dwarf_Func   None          dwarf_get_funcs
    .debug_typenames  Dwarf_Type   None          dwarf_get_types
    .debug_vars       Dwarf_Var    None          dwarf_get_vars
    .debug_weaks      Dwarf_Weak   None          dwarf_get_weaks
    @endcode

*/
