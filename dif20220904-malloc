git diff set for text
diff --git a/src/bin/dwarfdump/dd_addrmap.c b/src/bin/dwarfdump/dd_addrmap.c
index 252762ea..d38990d7 100644
--- a/src/bin/dwarfdump/dd_addrmap.c
+++ b/src/bin/dwarfdump/dd_addrmap.c
@@ -45,6 +45,7 @@
 #include "dd_globals.h"
 #include "dd_addrmap.h"
 #include "dd_tsearchbal.h"
+#include "libdwarf_private.h"
 
 static struct Addr_Map_Entry *
 addr_map_create_entry(Dwarf_Unsigned k,char *name)
diff --git a/src/bin/dwarfdump/dd_attr_form.c b/src/bin/dwarfdump/dd_attr_form.c
index 7b1247b4..723e6476 100644
--- a/src/bin/dwarfdump/dd_attr_form.c
+++ b/src/bin/dwarfdump/dd_attr_form.c
@@ -42,6 +42,7 @@
 #include "dd_naming.h"
 #include "dd_attr_form.h"
 #include "dwarfdump-af-table.h"
+#include "libdwarf_private.h"
 
 #if 0
 static void
diff --git a/src/bin/dwarfdump/dd_command_options.c b/src/bin/dwarfdump/dd_command_options.c
index 03bbded4..4477960f 100644
--- a/src/bin/dwarfdump/dd_command_options.c
+++ b/src/bin/dwarfdump/dd_command_options.c
@@ -52,6 +52,7 @@
 #include "dd_compiler_info.h"
 #include "dd_regex.h"
 #include "dd_safe_strcpy.h"
+#include "libdwarf_private.h"
 
 static const char *remove_quotes_pair(const char *text);
 static char *special_program_name(char *n);
@@ -2083,6 +2084,13 @@ void arg_search_any(void)
     glflags.gf_search_is_on = TRUE;
     glflags.search_any_text = makename(dwoptarg);
     tempstr = remove_quotes_pair(glflags.search_any_text);
+    if (!tempstr){
+        fprintf(stderr,
+            "regcomp: unable to compile "
+            " search expression %s, out of memory\n",
+            glflags.search_any_text);
+        return;
+    }
     glflags.search_any_text = do_uri_translation(tempstr,ctx);
     if (strlen(glflags.search_any_text) <= 0) {
         arg_search_invalid();
@@ -2107,6 +2115,13 @@ void arg_search_match(void)
     glflags.gf_search_is_on = TRUE;
     glflags.search_match_text = makename(dwoptarg);
     tempstr = remove_quotes_pair(glflags.search_match_text);
+    if (!tempstr){
+        fprintf(stderr,
+            "regcomp: unable to compile "
+            " search expression match=%s, out of memory\n",
+            glflags.search_match_text);
+        return;
+    }
     glflags.search_match_text = do_uri_translation(tempstr,ctx);
     if (strlen(glflags.search_match_text) <= 0) {
         arg_search_invalid();
@@ -2133,6 +2148,13 @@ void arg_search_regex(void)
     glflags.gf_search_is_on = TRUE;
     glflags.search_regex_text = makename(dwoptarg);
     tempstr = remove_quotes_pair(glflags.search_regex_text);
+    if (!tempstr){
+        fprintf(stderr,
+            "regcomp: unable to compile "
+            " search regular expression %s, out of memory\n",
+            glflags.search_regex_text);
+        return;
+    }
     glflags.search_regex_text = do_uri_translation(tempstr,ctx);
     if (strlen(glflags.search_regex_text) > 0) {
         res = dd_re_comp(glflags.search_regex_text);
@@ -2849,6 +2871,7 @@ process_args(int argc, char *argv[])
         printf("%s option error.\n",glflags.program_name);
         printf("To see the options list: %s -h\n",
             glflags.program_name);
+        makename_destructor();
         exit(EXIT_FAILURE);
     }
     if (dwoptind < (argc - 1)) {
@@ -2857,6 +2880,7 @@ process_args(int argc, char *argv[])
         printf("Only a single object name is allowed\n");
         printf("To see the options list: %s -h\n",
             glflags.program_name);
+        makename_destructor();
         exit(EXIT_FAILURE);
     }
     if (dwoptind > (argc - 1)) {
@@ -2864,6 +2888,7 @@ process_args(int argc, char *argv[])
             glflags.program_name);
         printf("To see the options list: %s -h\n",
             glflags.program_name);
+        makename_destructor();
         exit(EXIT_FAILURE);
     }
     /*  FIXME: it seems silly to be printing section names
diff --git a/src/bin/dwarfdump/dd_common.c b/src/bin/dwarfdump/dd_common.c
index a8bbbb33..03aa26f9 100644
--- a/src/bin/dwarfdump/dd_common.c
+++ b/src/bin/dwarfdump/dd_common.c
@@ -46,6 +46,7 @@ Portions Copyright (C) 2011-2012 SN Systems Ltd.  .  All Rights Reserved.
 #include "dd_glflags.h"
 #include "dd_defined_types.h"
 #include "dd_sanitized.h"
+#include "libdwarf_private.h"
 
 /* PACKAGE_VERSION is from config.h */
 /*  The Linux/Unix version does not want a version string to print
diff --git a/src/bin/dwarfdump/dd_compiler_info.c b/src/bin/dwarfdump/dd_compiler_info.c
index 0de77cdc..b43e21b1 100644
--- a/src/bin/dwarfdump/dd_compiler_info.c
+++ b/src/bin/dwarfdump/dd_compiler_info.c
@@ -45,6 +45,7 @@
 #include "dd_safe_strcpy.h"
 #include "dd_command_options.h"
 #include "dd_compiler_info.h"
+#include "libdwarf_private.h"
 
 /* Record compilers  whose CU names have been seen.
    Full CU names recorded here, though only a portion
diff --git a/src/bin/dwarfdump/dd_dwconf.c b/src/bin/dwarfdump/dd_dwconf.c
index 9d2ece03..dadbfa49 100644
--- a/src/bin/dwarfdump/dd_dwconf.c
+++ b/src/bin/dwarfdump/dd_dwconf.c
@@ -55,6 +55,7 @@ Portions Copyright 2012 SN Systems Ltd. All rights reserved.
 #include "dd_sanitized.h"
 #include "dd_esb.h"
 #include "dd_safe_strcpy.h"
+#include "libdwarf_private.h"
 
 /* The nesting level is arbitrary,  2 should suffice.
    But at least this prevents an infinite loop.
@@ -381,6 +382,11 @@ find_a_file(const char *named_file,
                     continue;
                 }
                 lname = makename(buf);
+                if (!lname) {
+                    printf("Dwarfdump out of memory, "
+                        "Unable to find a default conf directory\n");
+                    return 0;
+                }
             }
         }
         if (glflags.gf_show_dwarfdump_conf) {
@@ -543,9 +549,19 @@ get_token(char *cp, struct token_s *outtok)
 {
     char *lcp = skipwhite(cp);
     unsigned tlen = find_token_len(lcp);
+    static int outofmem = FALSE;
 
     outtok->tk_len = tlen;
     if (tlen > 0) {
+        char *src = build_string(tlen, lcp);
+        if (!src) {
+             if (!outofmem) {
+                 printf("Dwarfdump out of memory reading "
+                     "dwarfdump.conf and will likely not work.\n");
+             }
+             outofmem = TRUE;
+             return "";
+        }
         outtok->tk_data = build_string(tlen, lcp);
     } else {
         outtok->tk_data = "";
diff --git a/src/bin/dwarfdump/dd_esb.c b/src/bin/dwarfdump/dd_esb.c
index bd1c59ff..e145d3f8 100644
--- a/src/bin/dwarfdump/dd_esb.c
+++ b/src/bin/dwarfdump/dd_esb.c
@@ -49,6 +49,7 @@
 #include <stdarg.h> /* va_end() va_start() */
 #include <stdlib.h> /* exit() free() malloc() realloc() */
 #include <string.h> /* memcpy() memset() strlen() */
+#include "libdwarf_private.h"
 
 #include "dd_esb.h"
 
diff --git a/src/bin/dwarfdump/dd_getopt.c b/src/bin/dwarfdump/dd_getopt.c
index 47f41c36..c3b7609b 100644
--- a/src/bin/dwarfdump/dd_getopt.c
+++ b/src/bin/dwarfdump/dd_getopt.c
@@ -54,6 +54,7 @@
 #include <stddef.h> /* NULL size_t */
 #include <stdio.h>  /* fprintf() */
 #include <string.h> /* strlen() strchr() strcmp() strncmp() */
+#include "libdwarf_private.h"
 
 #include "dd_getopt.h"
 
diff --git a/src/bin/dwarfdump/dd_glflags.c b/src/bin/dwarfdump/dd_glflags.c
index 1e884ed9..4719455b 100644
--- a/src/bin/dwarfdump/dd_glflags.c
+++ b/src/bin/dwarfdump/dd_glflags.c
@@ -41,6 +41,7 @@ Copyright (C) 2017-2020 David Anderson. All Rights Reserved.
 #include "dd_checkutil.h"
 #include "dd_glflags.h"
 #include "dd_safe_strcpy.h"
+#include "libdwarf_private.h"
 
 #ifdef TRIVIAL_NAMING  /* for make rebuild */
 struct glflags_s glflags;
diff --git a/src/bin/dwarfdump/dd_helpertree.c b/src/bin/dwarfdump/dd_helpertree.c
index ddcf35f9..a9f42b4c 100644
--- a/src/bin/dwarfdump/dd_helpertree.c
+++ b/src/bin/dwarfdump/dd_helpertree.c
@@ -35,6 +35,7 @@
 #include "dd_globals.h"
 #include "dd_tsearchbal.h"
 #include "dd_helpertree.h"
+#include "libdwarf_private.h"
 
 #define TRUE 1
 #define FALSE 0
diff --git a/src/bin/dwarfdump/dd_macrocheck.c b/src/bin/dwarfdump/dd_macrocheck.c
index 8aaa854a..77d702e4 100644
--- a/src/bin/dwarfdump/dd_macrocheck.c
+++ b/src/bin/dwarfdump/dd_macrocheck.c
@@ -59,6 +59,7 @@
 #include "dd_tsearchbal.h"
 #include "dd_macrocheck.h"
 #include "dd_esb.h"
+#include "libdwarf_private.h"
 
 /*  WARNING: the tree walk functions will, if presented **tree
     when *tree is wanted, simply find nothing. No error,
diff --git a/src/bin/dwarfdump/dd_makename.c b/src/bin/dwarfdump/dd_makename.c
index 3785b655..77cd6a4e 100644
--- a/src/bin/dwarfdump/dd_makename.c
+++ b/src/bin/dwarfdump/dd_makename.c
@@ -40,6 +40,7 @@ Portions Copyright(C) David Anderson 2016-2019. All Rights reserved.
 
 #include <config.h>
 
+#include <stdio.h>
 #include <stdlib.h> /* free() */
 #include <string.h> /* strcmp() strdup() */
 
@@ -49,6 +50,7 @@ Portions Copyright(C) David Anderson 2016-2019. All Rights reserved.
 #include "dd_globals.h"
 #include "dd_tsearchbal.h"
 #include "dd_makename.h"
+#include "libdwarf_private.h"
 
 static void * makename_data;
 #define VALTYPE char *
@@ -66,6 +68,7 @@ static void
 value_node_free(void *valp)
 {
     VALTYPE v = (VALTYPE)valp;
+    /*printf("dadebug makename destroy %s\n",v);*/
     free(v);
 }
 
@@ -106,9 +109,10 @@ makename(const char *s)
     }
     retval = dwarf_tsearch(newstr,&makename_data, value_compare_func);
     if (!retval) {
-        /*  Out of memory, lets just use the string we dup'd and
-            let it leak. Things will surely fail anyway. */
-        return newstr;
+        /*  Out of memory, */
+        /*  return newstr; */
+        free(newstr);
+        return NULL;
     }
     re = *(VALTYPE *)retval;
     return re;
diff --git a/src/bin/dwarfdump/dd_naming.c b/src/bin/dwarfdump/dd_naming.c
index 8ef03164..c09100fd 100644
--- a/src/bin/dwarfdump/dd_naming.c
+++ b/src/bin/dwarfdump/dd_naming.c
@@ -36,6 +36,7 @@ Portions Copyright (C) 2010-2012 SN Systems Ltd. All Rights Reserved.
 #include "dd_makename.h"
 #include "dd_naming.h"
 #include "dd_esb.h"
+#include "libdwarf_private.h"
 
 #ifndef TRIVIAL_NAMING
 static const char *
@@ -98,6 +99,11 @@ ellipname(int   res,
 #endif
 
         n = makename(esb_get_string(&eb));
+        if (!n) {
+            printf("Out of memory extracting ellipsis name\n");
+            esb_destructor(&eb);
+            return "";
+        }
         esb_destructor(&eb);
         return n;
     }
diff --git a/src/bin/dwarfdump/dd_safe_strcpy.c b/src/bin/dwarfdump/dd_safe_strcpy.c
index c9d1e4cd..9e5a3da3 100644
--- a/src/bin/dwarfdump/dd_safe_strcpy.c
+++ b/src/bin/dwarfdump/dd_safe_strcpy.c
@@ -34,6 +34,7 @@ EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 #include <stddef.h> /* NULL size_t */
 #include "dd_safe_strcpy.h"
+#include "libdwarf_private.h"
 
 /*  An strcpy/strncpy which ensures NUL terminated string
     and never overruns the output.
diff --git a/src/bin/dwarfdump/dd_sanitized.c b/src/bin/dwarfdump/dd_sanitized.c
index 3c7ba97d..ea5a9761 100644
--- a/src/bin/dwarfdump/dd_sanitized.c
+++ b/src/bin/dwarfdump/dd_sanitized.c
@@ -33,6 +33,7 @@ Copyright 2016-2018 David Anderson. All rights reserved.
 #include "dd_esb.h"
 #include "dd_glflags.h"
 #include "dd_sanitized.h"
+#include "libdwarf_private.h"
 
 /*  This does a uri-style conversion of control characters.
     So  SOH prints as %01 for example.
diff --git a/src/bin/dwarfdump/dd_section_bitmaps.c b/src/bin/dwarfdump/dd_section_bitmaps.c
index 64cd5b59..7939933a 100644
--- a/src/bin/dwarfdump/dd_section_bitmaps.c
+++ b/src/bin/dwarfdump/dd_section_bitmaps.c
@@ -32,6 +32,7 @@ Copyright (C) 2017-2018 David Anderson. All Rights Reserved.
 #include "dwarf.h"
 #include "libdwarf.h"
 #include "dd_globals.h"
+#include "libdwarf_private.h"
 /*  dd_section_bitmaps.h and .c actually involved  bits,
     bit shifting, and bit masks,
     but now the 'maps' are simple byte arrays.
diff --git a/src/bin/dwarfdump/dd_strstrnocase.c b/src/bin/dwarfdump/dd_strstrnocase.c
index eb817a99..cdb08b05 100644
--- a/src/bin/dwarfdump/dd_strstrnocase.c
+++ b/src/bin/dwarfdump/dd_strstrnocase.c
@@ -60,6 +60,7 @@ strstrnocase.c
 #include "dwarf.h"
 #include "libdwarf.h"
 #include "dd_globals.h"
+#include "libdwarf_private.h"
 
 Dwarf_Bool
 is_strstrnocase(const char * container, const char * contained)
diff --git a/src/bin/dwarfdump/dd_true_section_name.c b/src/bin/dwarfdump/dd_true_section_name.c
index f6e4c1b3..e7d7c62d 100644
--- a/src/bin/dwarfdump/dd_true_section_name.c
+++ b/src/bin/dwarfdump/dd_true_section_name.c
@@ -34,6 +34,7 @@
 #include "dd_globals.h"
 #include "dd_esb.h"
 #include "dd_esb_using_functions.h"
+#include "libdwarf_private.h"
 
 void get_true_section_name(Dwarf_Debug dbg,
     const char *standard_name,
diff --git a/src/bin/dwarfdump/dd_tsearchbal.c b/src/bin/dwarfdump/dd_tsearchbal.c
index 50db0828..cb769978 100644
--- a/src/bin/dwarfdump/dd_tsearchbal.c
+++ b/src/bin/dwarfdump/dd_tsearchbal.c
@@ -70,6 +70,7 @@ EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 #include "libdwarf.h"
 #include "libdwarf_private.h"
 #include "dd_tsearchbal.h"
+#include "libdwarf_private.h"
 
 #define IMPLEMENTD15 1
 
diff --git a/src/bin/dwarfdump/dd_uri.c b/src/bin/dwarfdump/dd_uri.c
index 6e2f8564..209cb3cd 100644
--- a/src/bin/dwarfdump/dd_uri.c
+++ b/src/bin/dwarfdump/dd_uri.c
@@ -33,6 +33,7 @@ Portions Copyright 2012 SN Systems Ltd. All rights reserved.
 #include "dd_globals.h"
 #include "dd_esb.h"
 #include "dd_uri.h"
+#include "libdwarf_private.h"
 
 /* dwarfdump_ctype table. See uritablebuild.c */
 static char dwarfdump_ctype_table[256] = {
diff --git a/src/bin/dwarfdump/dwarfdump.c b/src/bin/dwarfdump/dwarfdump.c
index db42e926..27fe2f64 100644
--- a/src/bin/dwarfdump/dwarfdump.c
+++ b/src/bin/dwarfdump/dwarfdump.c
@@ -2271,6 +2271,10 @@ add_to_unique_errors_table(char * error_text)
 
     /* Create a copy of the incoming text */
     filtered_text = makename(error_text);
+    if (!filtered_text) {
+        /* Lets not do anything. */
+        return TRUE;
+    }
     len = strlen(filtered_text);
 
     /*  Remove from the error_text, any hexadecimal
diff --git a/src/bin/dwarfdump/print_sections.c b/src/bin/dwarfdump/print_sections.c
index c97df5d2..7286bfc9 100644
--- a/src/bin/dwarfdump/print_sections.c
+++ b/src/bin/dwarfdump/print_sections.c
@@ -37,6 +37,7 @@ Portions Copyright 2008-2011 David Anderson. All rights reserved.
 #include "dd_esb.h"
 #include "print_sections.h"
 #include "print_frames.h"
+#include "libdwarf_private.h"
 
 /*
     Print line number information:
diff --git a/src/bin/dwarfdump/print_static_funcs.c b/src/bin/dwarfdump/print_static_funcs.c
index a4a18a63..11ade1da 100644
--- a/src/bin/dwarfdump/print_static_funcs.c
+++ b/src/bin/dwarfdump/print_static_funcs.c
@@ -38,6 +38,7 @@ Portions Copyright 2008-2011 David Anderson. All rights reserved.
 #include "print_sections.h"
 #include "print_frames.h"
 #include "dd_sanitized.h"
+#include "libdwarf_private.h"
 
 /* Get all the data in .debug_funcnames
    An SGI extension.
diff --git a/src/bin/dwarfdump/print_static_vars.c b/src/bin/dwarfdump/print_static_vars.c
index 2be79783..c1f7ab0e 100644
--- a/src/bin/dwarfdump/print_static_vars.c
+++ b/src/bin/dwarfdump/print_static_vars.c
@@ -39,6 +39,7 @@ Portions Copyright 2008-2011 David Anderson. All rights reserved.
 #include "print_sections.h"
 #include "print_frames.h"
 #include "dd_sanitized.h"
+#include "libdwarf_private.h"
 
 /*  Get all the data in .debug_varnames
     (an SGI extension) */
diff --git a/src/bin/dwarfdump/print_strings.c b/src/bin/dwarfdump/print_strings.c
index 9031b1b4..fd01cf17 100644
--- a/src/bin/dwarfdump/print_strings.c
+++ b/src/bin/dwarfdump/print_strings.c
@@ -40,6 +40,7 @@ Portions Copyright 2008-2012 David Anderson. All rights reserved.
 #include "dd_sanitized.h"
 
 #include "print_sections.h"
+#include "libdwarf_private.h"
 
 static void
 print_sec_name(Dwarf_Debug dbg)
diff --git a/src/bin/dwarfdump/print_types.c b/src/bin/dwarfdump/print_types.c
index eaeaaa8f..86985b92 100644
--- a/src/bin/dwarfdump/print_types.c
+++ b/src/bin/dwarfdump/print_types.c
@@ -39,6 +39,7 @@ Portions Copyright 2008-2011 David Anderson. All rights reserved.
 #include "print_sections.h"
 #include "print_frames.h"
 #include "dd_sanitized.h"
+#include "libdwarf_private.h"
 
 /* Get all the data in .debug_typenames or debug_pubtypes. */
 int
diff --git a/src/bin/dwarfdump/print_weaknames.c b/src/bin/dwarfdump/print_weaknames.c
index 9b0adcbb..0eab8876 100644
--- a/src/bin/dwarfdump/print_weaknames.c
+++ b/src/bin/dwarfdump/print_weaknames.c
@@ -39,6 +39,7 @@ Portions Copyright 2008-2011 David Anderson. All rights reserved.
 #include "dd_sanitized.h"
 
 #include "print_sections.h"
+#include "libdwarf_private.h"
 
 /* Get all the data in .debug_weaknames */
 extern int
diff --git a/src/lib/libdwarf/Makefile.am b/src/lib/libdwarf/Makefile.am
index e91f169d..fa7fd128 100644
--- a/src/lib/libdwarf/Makefile.am
+++ b/src/lib/libdwarf/Makefile.am
@@ -63,6 +63,8 @@ dwarf_leb.c \
 dwarf_line.c \
 dwarf_line.h \
 dwarf_line_table_reader_common.h \
+localmalloc.c \
+localmalloc.h \
 dwarf_loc.c \
 dwarf_loc.h \
 dwarf_locationop_read.c \
diff --git a/src/lib/libdwarf/dwarf_alloc.c b/src/lib/libdwarf/dwarf_alloc.c
index 73fcd003..35bc37a8 100644
--- a/src/lib/libdwarf/dwarf_alloc.c
+++ b/src/lib/libdwarf/dwarf_alloc.c
@@ -79,8 +79,8 @@
 #include "dwarf_string.h"
 #include "dwarf_str_offsets.h"
 
-/* if DEBUG is defined a lot of stdout is generated here. */
-#undef DEBUG
+/* if DEBUG_ALLOC is defined a lot of stdout is generated here. */
+#define DEBUG_ALLOC 1 
 /*  Some allocations are simple some not. These reduce
     the issue of determining which sort of thing to a simple
     test. See ia_multiply_count
@@ -143,9 +143,10 @@ _dwarf_error_destructor(void *m)
     if (! erm) {
         return;
     }
-#if DEBUG
+#if DEBUG_ALLOC
     printf("libdwarfdetector DEALLOC Now destruct error "
         "string %s\n",dwarfstring_string(erm));
+    fflush(stdout);
 #endif
     dwarfstring_destructor(erm);
     free(erm);
@@ -486,21 +487,23 @@ _dwarf_get_alloc(Dwarf_Debug dbg,
     short action = 0;
 
     if (dbg == NULL) {
-#if DEBUG
+#if DEBUG_ALLOC
         printf("libdwarfdetector ALLOC dbg null  "
             "ret NULL type 0x%x size %lu line %d %s\n",
             (unsigned)alloc_type,(unsigned long)size,
             __LINE__,__FILE__);
+        fflush(stdout);
 #endif
         return NULL;
     }
     if (type >= ALLOC_AREA_INDEX_TABLE_MAX) {
         /* internal error */
-#if DEBUG
+#if DEBUG_ALLOC
         printf("libdwarfdetector ALLOC type bad ret null  "
             "ret NULL type 0x%x size %lu line %d %s\n",
             (unsigned)alloc_type,(unsigned long)size,
             __LINE__,__FILE__);
+        fflush(stdout);
 #endif
         return NULL;
     }
@@ -543,10 +546,11 @@ _dwarf_get_alloc(Dwarf_Debug dbg,
                 /*  We leak what we allocated in
                     _dwarf_find_memory when
                     constructor fails. */
-#if DEBUG
+#if DEBUG_ALLOC
     printf("libdwarfdetector ALLOC constructor fails ret NULL "
         "type 0x%x size %lu line %d %s\n",
         (unsigned)alloc_type,(unsigned long)size,__LINE__,__FILE__);
+    fflush(stdout);
 #endif
                 return NULL;
             }
@@ -568,11 +572,12 @@ _dwarf_get_alloc(Dwarf_Debug dbg,
                     pretend all is well. */
             }
         }
-#if DEBUG
-    printf("libdwarfdetector ALLOC ret 0x%lx type 0x%x "
-        "size %lu line %d %s\n",
+#if DEBUG_ALLOC
+        printf("libdwarfdetector ALLOC ret 0x%lx type 0x%x "
+            "size %lu line %d %s\n",
         (unsigned long)ret_mem,(unsigned)alloc_type,
         (unsigned long)size,__LINE__,__FILE__);
+        fflush(stdout);
 #endif
         return (ret_mem);
     }
@@ -628,7 +633,7 @@ dwarf_dealloc_die( Dwarf_Die die)
     Dwarf_CU_Context context = 0;
 
     if (!die) {
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
         printf("DEALLOC die does nothing, die NULL line %d %s\n",
             __LINE__,__FILE__);
         fflush(stdout);
@@ -637,7 +642,7 @@ dwarf_dealloc_die( Dwarf_Die die)
     }
     context = die->di_cu_context;
     if (!context) {
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
         printf("DEALLOC die does nothing, context NULL line %d %s\n",
             __LINE__,__FILE__);
         fflush(stdout);
@@ -657,7 +662,7 @@ dwarf_dealloc_attribute(Dwarf_Attribute attr)
     Dwarf_Debug dbg = 0;
 
     if (!attr) {
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
         printf("DEALLOC does nothing, attr is NULL line %d %s\n",
             __LINE__,__FILE__);
         fflush(stdout);
@@ -703,21 +708,32 @@ dwarf_dealloc(Dwarf_Debug dbg,
     struct reserve_data_s * r = 0;
 
     if (!space) {
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
         printf("DEALLOC does nothing, space NULL line %d %s\n",
             __LINE__,__FILE__);
         fflush(stdout);
-#endif /* DEBUG*/
+#endif /* DEBUG_ALLOC*/
         return;
     }
     if (!dbg) {
         /*  App error, or an app that failed in a
             dwarf_init*() or dwarf_elf_init*() call. */
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
         printf( "DEALLOC dbg NULL line %d %s\n",
             __LINE__,__FILE__);
         fflush(stdout);
-#endif /* DEBUG*/
+#endif /* DEBUG_ALLOC*/
+        return;
+    }
+    if(space == (Dwarf_Ptr)&_dwarf_failsafe_error) {
+#ifdef DEBUG_ALLOC
+        printf("DEALLOC failsafe requested at 0x%lx. "
+            "ignore. line %d %s\n",
+            (unsigned long)space,
+            __LINE__,__FILE__);
+        fflush(stdout);
+        return;
+#endif /* DEBUG_ALLOC*/
     }
     if (dbg && dbg->de_alloc_tree) {
         /*  If it's a string in debug_info etc doing
@@ -730,11 +746,11 @@ dwarf_dealloc(Dwarf_Debug dbg,
                 no need of a specialdestructor().
                 Mostly a historical mistake here.
                 Corrected in libdwarf March 14,2020. */
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
             printf( "DEALLOC string in section, no dealloc "
                 "line %d %s\n", __LINE__,__FILE__);
             fflush(stdout);
-#endif /* DEBUG*/
+#endif /* DEBUG_ALLOC*/
             return;
         }
     }
@@ -752,7 +768,7 @@ dwarf_dealloc(Dwarf_Debug dbg,
     r =(struct reserve_data_s *)malloc_addr;
     if (dbg && dbg != r->rd_dbg) {
         /*  Mixed up or originally a no_dbg alloc */
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
         printf("DEALLOC find was NULL  dbg 0x%lx "
             "rd_dbg 0x%lx space 0x%lx line %d %s\n",
             (unsigned long)dbg,
@@ -760,11 +776,11 @@ dwarf_dealloc(Dwarf_Debug dbg,
             (unsigned long)space,
             __LINE__,__FILE__);
         fflush(stdout);
-#endif /* DEBUG*/
+#endif /* DEBUG_ALLOC*/
     }
     if (dbg && alloc_type != r->rd_type) {
         /*  Something is mixed up. */
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
         printf("DEALLOC does nothing, type 0x%lx rd_type 0x%lx"
             " space 0x%lx line %d %s\n",
             (unsigned long)alloc_type,
@@ -772,7 +788,7 @@ dwarf_dealloc(Dwarf_Debug dbg,
             (unsigned long)space,
             __LINE__,__FILE__);
         fflush(stdout);
-#endif /* DEBUG*/
+#endif /* DEBUG_ALLOC*/
         return;
     }
     if (alloc_type == DW_DLA_ERROR) {
@@ -789,21 +805,21 @@ dwarf_dealloc(Dwarf_Debug dbg,
             _dwarf_failsafe_error.er_errval =
                 DW_DLE_FAILSAFE_ERRVAL;
             _dwarf_error_destructor(ep);
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
             printf("DEALLOC does nothing, DE_STATIC line %d %s\n",
                 __LINE__,__FILE__);
             fflush(stdout);
-#endif /* DEBUG*/
+#endif /* DEBUG_ALLOC*/
             return;
         }
         if (ep->er_static_alloc == DE_MALLOC) {
             /*  This is special, we had no arena
                 but have a full special area as normal. */
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
             printf("DEALLOC does free, DE_MALLOC line %d %s\n",
                 __LINE__,__FILE__);
             fflush(stdout);
-#endif /* DEBUG*/
+#endif /* DEBUG_ALLOC*/
 #if 0
             _dwarf_error_destructor(ep);
             free(space);
@@ -816,7 +832,7 @@ dwarf_dealloc(Dwarf_Debug dbg,
     /*  alloc types are a defined library-private
         set of integers. Less than 256 of them. */
     type = (unsigned int)alloc_type;
-#if DEBUG
+#if DEBUG_ALLOC
     if (dbg != r->rd_dbg) {
         printf("DEALLOC  dbg != rd_dbg"
             " going ahead line %d %s\n",
@@ -824,7 +840,7 @@ dwarf_dealloc(Dwarf_Debug dbg,
         fflush(stdout);
     }
 #endif
-#if DEBUG
+#if DEBUG_ALLOC
     printf("libdwarfdetector DEALLOC ret 0x%lx type 0x%x "
         "size %lu line %d %s\n",
         (unsigned long)space,(unsigned)type,
@@ -832,11 +848,11 @@ dwarf_dealloc(Dwarf_Debug dbg,
 #endif
     if (type >= ALLOC_AREA_INDEX_TABLE_MAX) {
         /* internal or user app error */
-#ifdef DEBUG
+#ifdef DEBUG_ALLOC
         printf("DEALLOC does nothing, type too big %lu line %d %s\n",
             (unsigned long)type,
             __LINE__,__FILE__);
-#endif /* DEBUG*/
+#endif /* DEBUG_ALLOC*/
         return;
     }
     if (alloc_instance_basics[type].specialdestructor) {
diff --git a/src/lib/libdwarf/dwarf_harmless.c b/src/lib/libdwarf/dwarf_harmless.c
index 3ff4aa81..033a6a54 100644
--- a/src/lib/libdwarf/dwarf_harmless.c
+++ b/src/lib/libdwarf/dwarf_harmless.c
@@ -190,12 +190,14 @@ unsigned dwarf_set_harmless_error_list_size(Dwarf_Debug dbg,
 /*  Only callable from within libdwarf (as a practical matter)
 */
 void
-_dwarf_harmless_init(struct Dwarf_Harmless_s *dhp,unsigned size)
+_dwarf_harmless_init(struct Dwarf_Harmless_s *dhp,
+    unsigned size)
 {
     unsigned i = 0;
     memset(dhp,0,sizeof(*dhp));
     dhp->dh_maxcount = size +1;
-    dhp->dh_errors = (char **)malloc(sizeof(char *)*dhp->dh_maxcount);
+    dhp->dh_errors = (char **)calloc(sizeof(char *),
+        dhp->dh_maxcount);
     if (!dhp->dh_errors) {
         dhp->dh_maxcount = 0;
         return;
@@ -203,17 +205,18 @@ _dwarf_harmless_init(struct Dwarf_Harmless_s *dhp,unsigned size)
 
     for (i = 0; i < dhp->dh_maxcount; ++i) {
         char *newstr =
-            (char *)malloc(DW_HARMLESS_ERROR_MSG_STRING_SIZE);
-        dhp->dh_errors[i] = newstr;
+            (char *)calloc(1,
+            DW_HARMLESS_ERROR_MSG_STRING_SIZE);
+#if 0
         if (!newstr) {
             dhp->dh_maxcount = 0;
             /* Let it leak, the leak is a constrained amount. */
+            free(dhp->dh_errors);
             dhp->dh_errors = 0;
             return;
         }
-        /*  We make the string content well-defined by an initial
-            NUL byte, but this is not really necessary. */
-        newstr[0] = 0;
+#endif
+        dhp->dh_errors[i] = newstr;
     }
 }
 
diff --git a/src/lib/libdwarf/dwarf_init_finish.c b/src/lib/libdwarf/dwarf_init_finish.c
index e6c4a416..a944ac4b 100644
--- a/src/lib/libdwarf/dwarf_init_finish.c
+++ b/src/lib/libdwarf/dwarf_init_finish.c
@@ -1649,7 +1649,7 @@ int
 dwarf_object_finish(Dwarf_Debug dbg)
 {
     int res = 0;
-
+    _dwarf_harmless_cleanout(&dbg->de_harmless_errors);
     res = _dwarf_free_all_of_one_debug(dbg);
     return res;
 }
diff --git a/src/lib/libdwarf/libdwarf_private.h b/src/lib/libdwarf/libdwarf_private.h
index 6cf876dc..be2ed853 100644
--- a/src/lib/libdwarf/libdwarf_private.h
+++ b/src/lib/libdwarf/libdwarf_private.h
@@ -11,6 +11,16 @@
 #define LIBDWARF_PRIVATE_H
 #define DW_PR_XZEROS "08"
 
+#ifndef MDEF
+#define malloc my_malloc
+#define calloc my_calloc
+#endif
+
+#include <stddef.h> /*  For size_t */
+void * my_malloc(size_t size);
+void * my_calloc(size_t nmemb,size_t size);
+
+
 #ifdef _WIN32
 #define DW_PR_DUx "I64x"
 #define DW_PR_DSx "I64x"
diff --git a/src/lib/libdwarf/localmalloc.c b/src/lib/libdwarf/localmalloc.c
index 7f80a695..4e89f929 100644
--- a/src/lib/libdwarf/localmalloc.c
+++ b/src/lib/libdwarf/localmalloc.c
@@ -6,14 +6,32 @@
 #define MDEF
 #include "localmalloc.h"
 
-
+static int mset = 0;
 static unsigned long maxcount = 0;
 static unsigned long curcount = 0;
+static void
+setmax(void) 
+{
+    char *e = getenv("MAXMALLOC");
+    if (e) {
+        long v = atol(e);
+        maxcount = (unsigned long)v;
+printf("Set maxcount %lu\n",maxcount);
+        mset = 1;
+        return;
+    } else {
+    }
+    mset = 1;
+    return;
+}
 
 void *
 my_malloc(size_t size)
 {
-printf("curcount %lu max %lu\n",curcount,maxcount);
+    /* printf("curcount %lu max %lu\n",curcount,maxcount); */
+    if (!mset) { 
+       setmax();
+    }
     if (curcount > maxcount) {
 printf("FAIL1\n");
         ++curcount;
@@ -27,7 +45,10 @@ printf("FAIL1\n");
 void *
 my_calloc(size_t nmemb,size_t size)
 {
-printf("curcount %lu max %lu\n",curcount,maxcount);
+    if (!mset) { 
+       setmax();
+    }
+    /* printf("curcount %lu max %lu\n",curcount,maxcount); */
     if (curcount > maxcount) {
 printf("FAIL2\n");
         ++curcount;
@@ -37,7 +58,7 @@ printf("FAIL2\n");
     return calloc(nmemb,size);
 }
 
-
+#ifdef TEST
 int main(void)
 {
      void *v = my_malloc(100);
@@ -45,3 +66,4 @@ int main(void)
      printf("v %p\n",v);
      printf("y %p\n",y);
 }
+#endif
diff --git a/src/lib/libdwarf/localmalloc.h b/src/lib/libdwarf/localmalloc.h
index eec2e072..cb28750b 100644
--- a/src/lib/libdwarf/localmalloc.h
+++ b/src/lib/libdwarf/localmalloc.h
@@ -6,4 +6,4 @@
 #endif
 
 void * my_malloc(size_t size);
-void * my_calloc(size_t nmemn,size_t size);
+void * my_calloc(size_t nmemb,size_t size);
