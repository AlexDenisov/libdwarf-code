<?xml version="1.0" encoding="us-ascii"?>
<dwarfbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz id: 56666</fuzzer>

<datereported>2023-03-04</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability>  Denial of service with corrupt gnu_index section
</vulnerability>

<description> A corrupted .debug_gnu_index header was not
</description>

<datefixed></datefixed>

<references> regressiontests/
</references>

<gitfixid></gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz id: 56636</fuzzer>

<datereported>2023-03-03</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability>  Denial of service with corrupt .debug_addr section
</vulnerability>

<description> A corrupted .debug_addr header was not
</description>

<datefixed>2023-03-03</datefixed>

<references> regressiontests/ossfuzz56636/fuzz_debug_addr_access-4801779658522624.fuzz
</references>

<gitfixid>a3ab3f16ab67f4d976561fe0d863e1ed8b71f3c6</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz id: 56548 56443</fuzzer>

<datereported>2023-03-01</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability>  Denial of service with corrupt line table header
</vulnerability>

<description> With any one of a small set of corrupted data
</description>

<datefixed>2023-03-03</datefixed>

<references> regressiontests/ossfuzz56548/fuzz_findfuncbypc-5073632331431936
</references>

<gitfixid>89d3beccd161657760585967255bbabf67e5b4c9</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz id: 56465  56530 56443</fuzzer>

<datereported>2023-03-01</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Denial of Service with corrupt attribute
</vulnerability>

<description> With a particular data corruption
</description>

<datefixed>2023-03-02</datefixed>

<references> regressiontests/ossfuzz56465/fuzz_die_cu_offset-5866690199289856
</references>

<gitfixid>948352178dc791796ed574a961191844d8322493</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2023-01-24</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Denial of Service with DW_FORM_strx3
</vulnerability>

<description></description>

<datefixed>2023-01-24</datefixed>

<references> regressiontests/
</references>

<gitfixid></gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz</fuzzer>

<datereported>2022-12-28</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Denial of Service with fuzzed object.
</vulnerability>

<description> The fuzzed testcase has at least four major
  errors which libdwarf did not catch, leading
  to unpredictable library behavior, possibly
  including crashing the calling program.
  Things not noticed before the fix (and now resulting
  in error being reported):
  A) The object has just 2 sections,
  too few to be real.  at least 3 sections are needed
  to contain DWARF information of any kind.
  B) Section zero has non-zero contents, in violation
  of the Elf object specification.
  C) The header says section strings are in section
  zero (a violation of the Elf specification).
  D) Section 1 masquerades as .note.gnu.debug-id
  and the description size is gigantic (as is
  the section, which fits the description field
  length).
</description>

<datefixed>2023-01-09</datefixed>

<references> regressiontests/ossfuzz54724/clusterfuzz-54724-poc
</references>

<gitfixid>45f6d778811553a835916b60845933e6dda63b7f</gitfixid>

<tarrelease>libdwarf-0.6.0.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>unspecified</fuzzer>

<datereported>2022-08-27</datereported>

<reportedby>Han Zheng</reportedby>

<product>libdwarf</product>

<vulnerability> Double free on corrupted frame data.
</vulnerability>

<description> A carefully corrupted object file
  would cause libdwarf to do a double free in
  handling an error condition in
  dwarf_expand_frame_instructions().
  (in libdwarf/dwarf_frame.c)
  That could cause a segmentation violation or other
  major error, terminating the calling application and
  resulting in Denial Of Service.
</description>

<datefixed>2022-08-27</datefixed>

<references> regressiontests/hanzheng/fuzzedobject
</references>

<gitfixid>428235e3d132fb62faf7732735fdbb034d6264b4</gitfixid>

<tarrelease>libdwarf-0.5.0.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>ossfuzz</fuzzer>

<datereported>2022-05-01</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> buffer overflow in dwarf_form.c
</vulnerability>

<description> A carefully corrupted string
  would cause libdwarf to read outside of a buffer containing
  the string (one past the end) when checking the string
  to determine if it is a full path in processing
  a .gnu.debuglink section.
  That could cause a segmentation violation or other
  major error, terminating the calling application and
  resulting in Denial Of Service.
</description>

<datefixed>2022-07-23</datefixed>

<references> regressiontests/ossfuzz47150/clusterfuzz-testcase-minimized-fuzz_init_path-6727387238236160.fuzz
</references>

<gitfixid>24dff940cc4c71a9c3cb5475aee231b19163a12c</gitfixid>

<tarrelease>libdwarf-0.5.0.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2022-06-15</datereported>

<reportedby>Casper Sun</reportedby>

<product>libdwarf</product>

<vulnerability> buffer overflow in dwarf_form.c
</vulnerability>

<description> A carefully corrupted .debug_info section
  would cause libdwarf to read outside of a buffer containing
  a Dwarf_Sig8 symbolic reference.
  That could cause a segmentation violation or other
  major error, terminating the calling application and
  resulting in Denial Of Service.
  This failure to check for buffer overflow has been present
  since DWARF4 when DW_FORM_ref_sig8 was added to libdwarf.
</description>

<datefixed>2022-06-15</datefixed>

<references> regressiontests/sleicasper2/buffer-overflow-dwarf-form
</references>

<gitfixid>7ef09e1fc9ba07653dd078edb2408631c7969162</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2022-05-26</datereported>

<reportedby>Casper Sun</reportedby>

<product>libdwarf</product>

<vulnerability> buffer overflow in dwarf_globals.c
</vulnerability>

<description> A carefully corrupted .debug_pubnames section
  would cause libdwarf to read outside of a buffer containing
  the section contents.
  That could cause a segmentation violation or other
  major error, terminating the calling application and
  resulting in Denial Of Service.
  The bug has been present for many years.
</description>

<datefixed>2022-05-29</datefixed>

<references> regressiontests/sleicasper/bufferoverflow
</references>

<gitfixid>8151575a6ace77d005ca5bb5d71c1bfdba3f7069</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-41240</fuzzer>

<datereported>2021-11-20</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Out-of-memory in fuzz_init_path
</vulnerability>

<description> A corrupted object.
  The PE object section header for
  section .gnu_debuglink is corrupted. A very
  large number is in the VirtualSize field.
  Attempting a malloc for the section could
  succeed or might fail, resulting in
  Denial Of Service.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=41240</preline>
  </pre>
</description>

<datefixed>2021-11-21</datefixed>

<references> regressiontests/ ossfuzz41240/clusterfuzz-testcase-minimized-fuzz_init_path-5929343686148096
</references>

<gitfixid>a120c808234060c3c9b1872ab9a059aa1ac70b1d</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40896</fuzzer>

<datereported>2021-11-10</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Out-of-memory in fuzz_init_path
</vulnerability>

<description> A corrupted object.
  Several Elf section sizes and section offsets are larger than
  the file size.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40896</preline>
  </pre>
</description>

<datefixed>2021-11-12</datefixed>

<references> regressiontests/ossfuzz40896/clusterfuzz-testcase-fuzz_init_path-5337872492789760
  regressiontests/ossfuzz40896/clusterfuzz-testcase-minimized-fuzz_init_path-5337872492789760
</references>

<gitfixid>b7a119dc07c502c1334bcbf8dd04ca0e4d5f6ab6</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40895</fuzzer>

<datereported>2021-11-10</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Out-of-memory in fuzz_init_binary
</vulnerability>

<description> A corrupted object.
  Some Elf section sizes are larger than the file size.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40895</preline>
  </pre>
</description>

<datefixed>2021-11-12</datefixed>

<references> regressiontests/ossfuzz40895/clusterfuzz-testcase-fuzz_init_binary-4805508242997248
  regressiontests/ossfuzz40895/clusterfuzz-testcase-minimized-fuzz_init_binary-4805508242997248
</references>

<gitfixid>b7a119dc07c502c1334bcbf8dd04ca0e4d5f6ab6</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40802</fuzzer>

<datereported>2021-11-07</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Null-dereference READ in dwarf_object_init_b
</vulnerability>

<description> A corrupted object.
  The error handling code in  dwarf_object_init_b
  was not properly dealing with a NULL pointer
  Dwarf_Error *errp in the test code.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40802</preline>
  </pre>
</description>

<datefixed>2021-11-19</datefixed>

<references> regressiontests/ossfuzz40802/ clusterfuzz-testcase-fuzz_init_binary-5538015955517440.fuzz
  regressiontests/ossfuzz40802/clusterfuzz-testcase-minimized-fuzz_init_binary-5538015955517440.fuzz
</references>

<gitfixid>adf4dae25b39039f1821b095688c00f3010e1d37</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40801</fuzzer>

<datereported>2021-11-07</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability>  Timeout in fuzz_init_path
</vulnerability>

<description> A corrupted object. libdwarf detects it quickly now.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40801</preline>
  </pre>
</description>

<datefixed>2021-11-07</datefixed>

<references> regressiontests/ossfuzz801/clusterfuzz-testcase-fuzz_init_path-5443517279764480
  regressiontests/ossfuzz40801/clusterfuzz-testcase-minimized-fuzz_init_path-5443517279764480
</references>

<gitfixid>94dece3ce0f030d06da442a103bd6a5301410b25</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40799</fuzzer>

<datereported>2021-11-02</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Out-of-memory in fuzz_init_path
</vulnerability>

<description> A corrupted object.
  Gigantic section sizes or offsets were provoking
  a large malloc.  Now these are detected and
  no malloc is attempted (an error is returned).
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40799</preline>
  </pre>
</description>

<datefixed>2021-11-07</datefixed>

<references> regressiontests/ossfuzz40799/clusterfuzz-testcase-fuzz_init_path-5245778948390912
  regressiontests/ossfuzz40799/clusterfuzz-testcase-minimized-fuzz_init_path-5245778948390912
</references>

<gitfixid>94dece3ce0f030d06da442a103bd6a5301410b25</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40627</fuzzer>

<datereported>2021-11-02</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Abrt in _dwarf_error_string
</vulnerability>

<description> The Elf object file has some corruption. The
  read now stops with an error.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40627</preline>
  </pre>
</description>

<datefixed>2021-11-07</datefixed>

<references> regressiontests/ossfuzz40627/clusterfuzz-testcase-fuzz_init_path-5186858573758464
  regressiontests/ossfuzz40627/clusterfuzz-testcase-minimized-fuzz_init_path-5186858573758464
</references>

<gitfixid>94dece3ce0f030d06da442a103bd6a5301410b25</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40729</fuzzer>

<datereported>2021-11-05</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Timeout - fuzz_init_binary
</vulnerability>

<description> The object file (macho 64 bit) has some
  header fuzzing that was not caught reading
  the object until the macho reader
  tried a gigantic malloc..
  Now the library code catches the error before malloc and
  returns an error code.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40729</preline>
  </pre>
</description>

<datefixed>2021-11-07</datefixed>

<references> regressiontests/ossfuzz40729/clusterfuzz-testcase-minimized-fuzz_init_binary-4791627277795328
</references>

<gitfixid>94dece3ce0f030d06da442a103bd6a5301410b25</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40731</fuzzer>

<datereported>2021-11-03</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Out-of-memory in fuzz_init_binary
</vulnerability>

<description> The fuzzed macho64 object has corrupted
  headers. The library notices and reports an error.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40731</preline>
  </pre>
</description>

<datefixed>2021-11-07</datefixed>

<references> regressiontests/ossfuzz40731/clusterfuzz-testcase-fuzz_init_binary-5983147574034432
</references>

<gitfixid>94dece3ce0f030d06da442a103bd6a5301410b25</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40674</fuzzer>

<datereported>2021-11-03</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Heap-buffer-overflow in _dwarf_elf_setup_all_section_groups
</vulnerability>

<description>  Object file has corrupt section group information.
  Results in buffer overflow.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40674#c6</preline>
  </pre>
</description>

<datefixed>2021-11-07</datefixed>

<references> regressiontests/ossfuzz40674/clusterfuzz-testcase-minimized-fuzz_init_path-6557751518560256
</references>

<gitfixid>94dece3ce0f030d06da442a103bd6a5301410b25</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40673</fuzzer>

<datereported>2021-11-03</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Null-dereference READ in dwarf_object_init_b
</vulnerability>

<description> The macho object has corrupted headers
  and now mentions that and stops.
  Verified as fixed by oss-fuzz 2021-11-03
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40673</preline>
  </pre>
</description>

<datefixed>2021-11-05</datefixed>

<references> regressiontests/ossfuzz40673/clusterfuzz-testcase-minimized-fuzz_init_path-6240961391362048.fuzz
</references>

<gitfixid>94dece3ce0f030d06da442a103bd6a5301410b25</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40671</fuzzer>

<datereported>2021-11-03</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Direct-leak in _dwarf_get_debug
</vulnerability>

<description> The test code is calling a libdwarf-internal
  function (which is against the rules, only libdwarf
  function names beginning with dwarf_ are callable.
  When building libdwarf as an archive there is no
  means to enforce this rule)
  doc/libdwarf.mm/pdf now documents this rule.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40671</preline>
  </pre>
</description>

<datefixed>2021-11-05</datefixed>

<references> regressiontests/oss40671/clusterfuzz-testcase-fuzz_init_path-5455557297831936
  regressiontests/oss40671/clusterfuzz-testcase-minimized-fuzz_init_path-5455557297831936
</references>

<gitfixid>b40f7e291216e771185f62292dd6304b5a662926</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40669</fuzzer>

<datereported>2021-11-03</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Out-of-memory in fuzz_init_path
</vulnerability>

<description>  Corrupted MachO object can crash caller.b
  Two fields in the MachO file header
  were not checked for sanity so nonsense large values
  could lead to excessive malloc and or a caller
  segmentation violation. Fixed by DW202111-001.
  Verified as fixed by oss-fuzz
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40669</preline>
  </pre>
</description>

<datefixed>2021-11-04</datefixed>

<references> regressiontests/ossfuzz40669/clusterfuzz-testcase-minimized-fuzz_init_path-5399726397194240
  regressiontests/clusterfuzz-testcase-fuzz_init_path-5399726397194240
</references>

<gitfixid>b40f7e291216e771185f62292dd6304b5a662926</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer>oss-fuzz-40663</fuzzer>

<datereported>2021-11-03</datereported>

<reportedby>David Korczynski</reportedby>

<product>libdwarf</product>

<vulnerability> Timeout in fuzz_init_path
</vulnerability>

<description>  Corrupted MachO object can crash caller
  Two fields in the MachO file header
  were not checked for sanity so nonsense large values
  could lead to excessive malloc and or a caller
  segmentation violation.
  Verified by oss-fuzz as fixed.
  The testcase has illegal libdwarf call
  and improper include statements.
  <pre>
<preline>  https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=40663</preline>
  </pre>
</description>

<datefixed>2021-11-04</datefixed>

<references> regressiontests/ossfuzz40663/clusterfuzz-testcase-minimized-fuzz_init_path-6122542432124928
</references>

<gitfixid>b40f7e291216e771185f62292dd6304b5a662926</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2020-28163</cve>

<fuzzer></fuzzer>

<datereported>2020-10-27</datereported>

<reportedby>Casper Sun</reportedby>

<product>libdwarf</product>

<vulnerability> Passing null to %s due to corrupt line table header.
</vulnerability>

<description> If a DWARF5 line table header has an invalid
  FORM for a pathname, the fi_file_name field may be null
  and printing it via %s can result in referencing memory
  at address 0, possibly generating segmentation
  violation or application crash.  Now in case of null
  we provide a fixed string of &lt;no file name&gt;
  and for the form code we print the value and &lt;unknown form&gt;
  so there are no unpredictable effects.
  <pre>
<preline>  This should be visible after redhat makes it public.</preline>
<preline>  Filed on bugzilla.redhat 23 November 2021.</preline>
<preline>  bugzilla.redhat.com/show_bug.cgi?id=2026000</preline>
  </pre>
</description>

<datefixed>2020-10-28</datefixed>

<references> regressiontests/c-sun2/nullpointer
</references>

<gitfixid>faf99408e3f9f706fc3809dd400e831f989778d3</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2020-28162</cve>

<fuzzer></fuzzer>

<datereported>2020-10-27</datereported>

<reportedby>Casper Sun</reportedby>

<product>dwarfdump</product>

<vulnerability> dwarfdump crashes if the nest of C scopes is too deep
</vulnerability>

<description> An object file where the DIEs depth of
  nesting exceeds the limit of 800 levels
  due to corruption or a compiler bug
  can result in exhausting the die stack array and
  writing past its end.
  A segmentation fault is possible.
  The code at the point of error was not adjusting
  the array index properly
  so an invalid dereference could occur.
  Now the test code is correct and the array overflow
  is detected resulting in a normal error return.
  Additional places where this could occur were
  identified and the proper test added.
  <pre>
<preline>  Unable to enter in bugzilla.redhat.com</preline>
<preline>  so CVE can be completed by Fedora (as CNA)</preline>
<preline>  as dwarfdump is not part of Fedora</preline>
  </pre>
</description>

<datefixed>2020-10-28</datefixed>

<references> regressiontests/c-sun2/globaloverflow
</references>

<gitfixid>a7fa8edd640b74daf8e7a442dcec96640875b4fb</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2020-27545</cve>

<fuzzer></fuzzer>

<datereported>2020-10-10</datereported>

<reportedby>Casper Sun</reportedby>

<product>libdwarf</product>

<vulnerability> A carefully corrupted line table can crash calling app
</vulnerability>

<description> A carefully crafted object with an
  invalid line table could cause libdwarf
  to dereference a pointer reading a single byte outside of
  the intended .debug_line section and potentially
  outside of memory visible to the library.
  A segmentation fault is possible.
  The code testing for the error was coded incorrectly
  so an invalid dereference could occur.
  Now the test code is correct and the error
  is detected resulting in a normal error return.
  <pre>
<preline>  This should be visible after redhat makes it public.</preline>
<preline>  Filed on bugzilla.redhat 22 November 2021.</preline>
<preline>  bugzilla.redhat.com/show_bug.cgi?id=2025694</preline>
  </pre>
</description>

<datefixed>2020-10-17</datefixed>

<references> regressiontests/c-sun/poc
</references>

<gitfixid>95f634808c01f1c61bbec56ed2395af997f397ea</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2019-14249</cve>

<fuzzer></fuzzer>

<datereported>2019-07-23</datereported>

<reportedby>unknown</reportedby>

<product>libdwarf</product>

<vulnerability> Denial of service with zero size section group
</vulnerability>

<description> dwarf_elf_load_headers.c in libdwarf before 2019-07-05 allows attackers to cause a denial of service (division by zero) via an ELF file with a zero-size section group (SHT_GROUP), as demonstrated by dwarfdump.
</description>

<datefixed>2019-07-05</datefixed>

<references></references>

<gitfixid>cb7198abde46c2ae29957ad460da6886eaa606ba</gitfixid>

<tarrelease>libdwarf-0.4.1.tar.xz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2018-01-28</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>dwarfdump</product>

<vulnerability> Incorrect frame section can crash dwarfdump
</vulnerability>

<description> A carefully crafted object with an
  invalid frame section set of initial-instructions
  can crash the frame-instructions decode in
  dwarfdump. In addition, a couple places in libdwarf
  are not as careful in checking frame data as
  they should be.
  A segmentation-fault/core-dump is possible.
</description>

<datefixed>2018-01-29</datefixed>

<references> sarubbo-11/testcase{1,2,3,4,5}.bin
</references>

<gitfixid>7af0ecddfafed88446969cbf8c888356ad485d99</gitfixid>

<tarrelease>libdwarf-20180129.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2017-12-01</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> Incorrect frame section could let caller crash
</vulnerability>

<description> A carefully crafted object with an
  invalid frame section
  can result in passing back data to a caller of
  dwarf_get_fde_augmentation_data()
  is erroneous and will result in the
  caller reference off the end of the frame
  section.
  A segmentation-fault/core-dump is possible.
</description>

<datefixed>2017-12-01</datefixed>

<references> sarubbo-10/1.crashes.bin
</references>

<gitfixid>329ea8e56bc9550260cae6e2e9756bfbe7e2ff6d</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2017-11-08</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> Incorrect line table section could crash caller
</vulnerability>

<description> An carefully crafted object with a
  invalid line table section crafted to
  end early at a particular point resulted in
  dereferencing outside the line table from
  libdwarf/dwarf_line_table_reader_common.c .
  A segmentation-fault/core-dump is possible.
</description>

<datefixed>2017-11-08</datefixed>

<references> regressiontests/sarubbo-9/3.crashes.bin
</references>

<gitfixid>a1644f4dde7dd5990537ff7ad22a9e94b8723186</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2017-11-01</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> Incorrect frame section could crash caller
</vulnerability>

<description> A carefully crafted object with a
  resulting invalid frame section
  with DW_CFA_advance_loc1 implying
  data off-the-end-of-section
  will dereference an invalid pointer.
  A segmentation fault and core dump is possible.
  Corrected code checks now.
</description>

<datefixed>2017-11-02</datefixed>

<references> regressiontests/sarubbo-8/1.crashes.bin
</references>

<gitfixid>44349d7991e44dd3751794f76537cabcf65ee28d</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2017-09-19</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> Incorrect abbrev section could crash caller.
</vulnerability>

<description> A fuzzed object with a
  resulting invalid abbrev section where
  the end of section follows an abbrev tag
  would dereference a non-existent has-child byte.
</description>

<datefixed>2017-09-26</datefixed>

<references> regressiontests/sarubbo-3/1.crashes.bin
</references>

<gitfixid>bcc2e33908e669bacd397e3c941ffd1db3005d17</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2017-9998</cve>

<fuzzer></fuzzer>

<datereported>2017-06-28</datereported>

<reportedby>team OWL337</reportedby>

<product>libdwarf</product>

<vulnerability> Addition overflow in libdwarf leads to segmentation violation
</vulnerability>

<description> A fuzzed object with a
  resulting invalid value can overflow
  when added to a valid pointer
  (depending on how the runtime memory is laid out)
  and thereafter a dereference results in a
  segmentation violation).
 <pre> see
<preline>  https://bugzilla.redhat.com/show_bug.cgi?id=1465756</preline>
<preline>  for contact information of those finding the bug.</preline>
<preline>  Fabian Wolff sent email and provided</preline>
<preline>  the link to the web page.</preline>
 </pre>
</description>

<datefixed>2017-07-06</datefixed>

<references> regressiontests/wolff/POC1
</references>

<gitfixid>e91681e8841291f57386f26a90897fd1dcf92a6e</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2017-03-21</datereported>

<reportedby>Marcel Bohme and Van-Thuan Pham</reportedby>

<product>libdwarf (libelf)</product>

<vulnerability> Heap overflow in strncmp (libelf bug)
</vulnerability>

<description>  7/7. A heap overflow in
  strncmp() is due to libelf failing to check arguments
  to elf_ strptr.
  This is not a bug in libdwarf, it is a libelf bug.
  A  pointer for being in bounds (in a few places in this
  function) and a failure in a check in dwarf_attr_list().
  The test object is intentionally corrupted (fuzzed).
 <pre>
<preline> A portion of sanitizer output with Ubuntu 14.04:</preline>
<preline> ==180133==ERROR: AddressSanitizer: heap-buffer-overflow</preline>
<preline>   on address 0x60d00000cff1 at pc 0x0000004476f4</preline>
<preline>   bp 0x7fff87dd7dd0 sp 0x7fff87dd7590</preline>
<preline> READ of size 8 at 0x60d00000cff1 thread T0</preline>
<preline>    #0 0x4476f3 in __interceptor_strncmp (/home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/dwarfdump/dwarfdump+0x4476f3)</preline>
<preline>    #1 0x7992ae in this_section_dwarf_relevant /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/libdwarf/dwarf_init_finish.c:608:13</preline>
<preline>    #2 0x781064 in _dwarf_setup /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/libdwarf/dwarf_init_finish.c:722:14</preline>
<preline>    #3 0x77d59c in dwarf_object_init /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/libdwarf/dwarf_init_finish.c:922:20</preline>
<preline> With Ubuntu 16.04 libelf dwarfdump gets:</preline>
<preline> ERROR:  dwarf_elf_init:  DW_DLE_ELF_STRPTR_ERROR (30)</preline>
<preline> a call to elf_strptr() failed trying to get a section name</preline>
 </pre>
 Fix date is irrelevant, libdwarf no longer uses libelf.
</description>

<datefixed></datefixed>

<references> regressiontests/marcel/crash7
</references>

<gitfixid></gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2017-9052</cve>

<fuzzer></fuzzer>

<datereported>2017-03-21</datereported>

<reportedby>Marcel Bohme and Van-Thuan Pham</reportedby>

<product>libdwarf</product>

<vulnerability> Heap overflow in dwarf_formsdata
</vulnerability>

<description>  6/7. A heap overflow in
  dwarf_formsdata() is due to a failure to check
  a  pointer for being in bounds (in a few places in this
  function) and a failure in a check in dwarf_attr_list().
  The test object is intentionally corrupted (fuzzed).
 <pre>
<preline> A portion of sanitizer output with Ubuntu 14.04:</preline>
<preline> ==180130==ERROR: AddressSanitizer: heap-buffer-overflow</preline>
<preline>  on address 0x61100000589c at pc 0x0000006cab95</preline>
<preline>  bp 0x7fff749aab10 sp 0x7fff749aab08</preline>
<preline> READ of size 1 at 0x61100000589c thread T0</preline>
<preline>    #0 0x6cab94 in dwarf_formsdata /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/libdwarf/dwarf_form.c:937:9</preline>
<preline>    #1 0x567daf in get_small_encoding_integer_and_name /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/dwarfdump/print_die.c:1533:16</preline>
<preline>    #2 0x562f28 in get_attr_value /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/dwarfdump/print_die.c:5030:24</preline>
<preline>    #3 0x555f86 in print_attribute /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/dwarfdump/print_die.c:3357:13</preline>
<preline> After fixes applied dwarfdump says:</preline>
<preline> ERROR:  dwarf_attrlist:  DW_DLE_DW_DLE_ATTR_OUTSIDE_SECTION(281)</preline>
 </pre>
</description>

<datefixed>2017-03-21</datefixed>

<references> regressiontests/marcel/crash6
</references>

<gitfixid>cc37d6917011733d776ae228af4e5d6abe9613c1</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2017-9053</cve>

<fuzzer></fuzzer>

<datereported>2017-03-21</datereported>

<reportedby>Marcel Bohme and Van-Thuan Pham</reportedby>

<product>libdwarf</product>

<vulnerability> Heap overflow in _dwarf_read_loc_expr_op()
</vulnerability>

<description>  5/7. A heap overflow in
  _dwarf_read_loc_expr_op() is due to a failure to check
  a  pointer for being in bounds (in a few places in this
  function).
  The test object is intentionally corrupted (fuzzed).
 <pre>
<preline> A portion of sanitizer output with Ubuntu 14.04:</preline>
<preline> ==180112==ERROR: AddressSanitizer: heap-buffer-overflow</preline>
<preline>  on address 0x60800000bf72 at pc 0x00000084dd52</preline>
<preline>  bp 0x7ffc12136fd0 sp 0x7ffc12136fc8</preline>
<preline> READ of size 1 at 0x60800000bf72 thread T0</preline>
<preline>    #0 0x84dd51 in _dwarf_read_loc_expr_op /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/libdwarf/./dwarf_loc.c:250:9</preline>
<preline>    #1 0x841f16 in _dwarf_get_locdesc_c /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/libdwarf/./dwarf_loc2.c:109:15</preline>
<preline>    #2 0x837d08 in dwarf_get_loclist_c /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/libdwarf/./dwarf_loc2.c:685:18</preline>
<preline>    #3 0x57dff2 in get_location_list /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/dwarfdump/print_die.c:3812:16</preline>
<preline> After fixes applied dwarfdump says:</preline>
<preline> ERROR:  dwarf_get_loclist_c:  DW_DLE_LOCEXPR_OFF_SECTION_END</preline>
<preline> (343) Corrupt dwarf</preline>
 </pre>
</description>

<datefixed>2017-03-21</datefixed>

<references> regressiontests/marcel/crash5
</references>

<gitfixid>cc37d6917011733d776ae228af4e5d6abe9613c1</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2017-03-21</datereported>

<reportedby>Marcel Bohme and Van-Thuan Pham</reportedby>

<product>libdwarf (libelf)</product>

<vulnerability> Heap overflow in set_up_section strlen
</vulnerability>

<description>  4/7. An apparent heap overflow that
  gives the appearance of being in libdwarf is due to
  libelf call elf_strptr() failing to fully check
  that its arguments make sense.
  This is not a bug in libdwarf, it is a libelf bug.
  The test object is intentionally corrupted (fuzzed).
  The submission was with Ubuntu 14.04. With Ubuntu
  16.04 there is no sanitizer error report.
 <pre>
<preline> A portion of sanitizer output with Ubuntu 14.04:</preline>
<preline> ==180109==ERROR: AddressSanitizer: heap-buffer-overflow</preline>
<preline>   on address 0x60b00000b000 at pc 0x00000048fd12</preline>
<preline>   bp 0x7fff4ad31ef0 sp 0x7fff4ad316b0</preline>
<preline> READ of size 16 at 0x60b00000b000 thread T0</preline>
<preline>    #0 0x48fd11 in __interceptor_strlen (/home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/dwarfdump/dwarfdump+0x48fd11)</preline>
<preline>    #1 0x7a84a4 in set_up_section /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:285:27</preline>
<preline>    #2 0x79aaa5 in enter_section_in_de_debug_sections_array /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:355:5</preline>
<preline>    #3 0x78170b in _dwarf_setup /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:746:19</preline>
<preline> With Ubuntu 16.04 libelf one gets:</preline>
<preline> ERROR:  dwarf_elf_init:  DW_DLE_ELF_STRPTR_ERROR (30)</preline>
<preline> a call to elf_strptr() failed trying to get a section name</preline>
 </pre>
</description>

<datefixed></datefixed>

<references> regressiontests/marcel/crash4
</references>

<gitfixid></gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2017-03-21</datereported>

<reportedby>Marcel Bohme and Van-Thuan Pham</reportedby>

<product>libdwarf (libelf)</product>

<vulnerability> Heap overflow in strcmp
</vulnerability>

<description>  3/7. An apparent heap overflow that
  gives the appearance of being in libdwarf is due to
  libelf call elf_strptr() failing to fully check
  that its arguments make sense.
  This is not a bug in libdwarf, it is a libelf bug.
  The test object is intentionally corrupted (fuzzed).
  The submission was with Ubuntu 14.04. With Ubuntu
  16.04 there is no sanitizer error report.
 <pre>
<preline> A portion of sanitizer output with Ubuntu 14.04:</preline>
<preline>  ==180106==ERROR: AddressSanitizer: heap-buffer-overflow</preline>
<preline>    on address 0x60f00000ef09 at pc 0x000000447300</preline>
<preline>    bp 0x7ffc667dce10 sp 0x7ffc667dc5d0</preline>
<preline>  READ of size 4 at 0x60f00000ef09 thread T0</preline>
<preline>    #0 0x4472ff in __interceptor_strcmp (/home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/dwarfdump/dwarfdump+0x4472ff)</preline>
<preline>    #1 0x79938f in this_section_dwarf_relevant /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:612:12</preline>
<preline>    #2 0x781064 in _dwarf_setup /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:722:14</preline>
<preline>    #3 0x77d59c in dwarf_object_init /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/libdwarf/dwarf_init_finish.c:922:20</preline>
<preline>    #4 0x899d4f in dwarf_elf_init_file_ownership /</preline>
<preline>  With Ubuntu 16.04 libelf one gets:</preline>
<preline>  ERROR:  dwarf_elf_init:  DW_DLE_ELF_STRPTR_ERROR (30)</preline>
<preline>  a call to elf_strptr() failed trying to get a section name</preline>
  </pre>
  Fix date is irrelevant, libdwarf no longer uses libelf.
</description>

<datefixed></datefixed>

<references> regressiontests/marcel/crash3
</references>

<gitfixid></gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2017-9054</cve>

<fuzzer></fuzzer>

<datereported>2017-03-21</datereported>

<reportedby>Marcel Bohme and Van-Thuan Pham</reportedby>

<product>libdwarf</product>

<vulnerability> Heap overflow in _dwarf_decode_s_leb128_chk()
</vulnerability>

<description>  2/7. In _dwarf_decode_s_leb128_chk()
  a byte pointer was dereferenced just before was checked
  as being in bounds.
  The test object is intentionally corrupted (fuzzed).
 <pre>
<preline> A portion of sanitizer output:</preline>
<preline>  .debug_line: line number info for a single cu</preline>
<preline>  ==180103==ERROR: AddressSanitizer: heap-buffer-overflow</preline>
<preline>    on address 0x610000007ffc at pc 0x0000007b0f5b</preline>
<preline>    bp 0x7ffe06bbf510 sp 0x7ffe06bbf508</preline>
<preline>  READ of size 1 at 0x610000007ffc thread T0</preline>
<preline>    #0 0x7b0f5a in _dwarf_decode_s_leb128_chk /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/libdwarf/dwarf_leb.c:304:9</preline>
<preline>    #1 0x7e753e in read_line_table_program /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/libdwarf/./</preline>
<preline>       dwarf_line_table_reader_common.c:1167:17</preline>
<preline>    #2 0x7d7fe3 in _dwarf_internal_srclines /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/libdwarf/./dwarf_line.c:690:15</preline>
<preline>    #3 0x7f9dbb in dwarf_srclines_b /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/libdwarf/./dwarf_line.c:944:12</preline>
<preline>    #4 0x5caaa5 in print_line_numbers_this_cu /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/dwarfdump/print_lines.c:762:16</preline>
<preline>  After fix applied one gets:</preline>
<preline>  ERROR:  dwarf_srclines:  DW_DLE_LEB_IMPROPER (329)</preline>
<preline>  Runs off end of section or CU</preline>
 </pre>
</description>

<datefixed>2017-03-21</datefixed>

<references> regressiontests/marcel/crash2
</references>

<gitfixid>cc37d6917011733d776ae228af4e5d6abe9613c1</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2017-9055</cve>

<fuzzer></fuzzer>

<datereported>2017-03-21</datereported>

<reportedby>Marcel Bohme and Van-Thuan Pham</reportedby>

<product>libdwarf</product>

<vulnerability> Heap overflow in dwarf_formsdata
</vulnerability>

<description>  1/7. In dwarf_formsdata() a few
  data types were not checked as being in bounds.
  The test object is intentionally corrupted (fuzzed).
 <pre>
<preline> A portion of sanitizer output:</preline>
<preline> LOCAL_SYMBOLS:</preline>
<preline> &lt; 1&gt;&lt;0x0000002f&gt;    DW_TAG_subprogram</preline>
<preline> ==180088==ERROR: AddressSanitizer: heap-buffer-overflow on</preline>
<preline>  address 0x60800000bf72 at pc 0x0000006cab95 bp</preline>
<preline>  0x7fff31425830 sp 0x7fff31425828</preline>
<preline>  READ of size 1 at 0x60800000bf72 thread T0</preline>
<preline>    #0 0x6cab94 in dwarf_formsdata /home/ubuntu/subjects/</preline>
<preline>       build-asan/libdwarf/libdwarf/dwarf_form.c:937:9</preline>
<preline>    #1 0x567daf in get_small_encoding_integer_and_name /home/</preline>
<preline>       ubuntu/subjects/build-asan/libdwarf/dwarfdump/print_die.c:1533:16</preline>
<preline>    #2 0x576f38 in check_for_type_unsigned /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/dwarfdump/print_die.c:4301:11</preline>
<preline>    #3 0x56ad8c in formxdata_print_value /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/dwarfdump/print_die.c:4374:39</preline>
<preline>    #4 0x5643be in get_attr_value /home/ubuntu/</preline>
<preline>       subjects/build-asan/libdwarf/dwarfdump/print_die.c:5140:24</preline>
<preline>    #5 0x555f86 in print_attribute /home/ubuntu/subjects/build</preline>
<preline>  ...</preline>
<preline>  After fixes applied dwarfdump gets:</preline>
<preline>  ERROR:  dwarf_attrlist:  DW_DLE_DW_DLE_ATTR_OUTSIDE_SECTION(281)</preline>
 </pre>
</description>

<datefixed>2017-03-21</datefixed>

<references> regressiontests/marcel/crash1
</references>

<gitfixid>cc37d6917011733d776ae228af4e5d6abe9613c1</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-10254</cve>

<fuzzer></fuzzer>

<datereported>2016-11-04</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> Crash libelf reading fuzzed object.
</vulnerability>

<description> This is a weakness in libelf checking.
  Testing that current libdwarf deals with it properly,
  though it was never a bug in libdwarf.
  The CVE mentions libdwarf.
  <pre>
<preline>  blogs.gentoo.org/ago/2016/11/04/elfutils-memory-allocation-failure-in-allocate_elf-common-h/</preline>
<preline>  www.openwall.com/lists/oss-security/2017/03/22/2</preline>
  </pre>
  Fixed in gentoo libelf by Agostino Sarubbo.
</description>

<datefixed>2016-11-04</datefixed>

<references> regressiontests/sarubbo-b/00011-elfutils-memalloc-allocate_elf
</references>

<gitfixid></gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-10255</cve>

<fuzzer></fuzzer>

<datereported>2016-11-04</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> Crash libelf reading fuzzed object.
</vulnerability>

<description> This is a weakness in libelf checking.
  Testing that current libdwarf deals with it properly,
  though it was never a bug in libdwarf.
  The CVE mentions libdwarf.
  <pre>
<preline>  bugzilla.redhat.com/show_bug.cgi?id=1387584</preline>
<preline>  www.openwall.com/lists/oss-security/2017/03/22/1</preline>
<preline>  blogs.gentoo.org/ago/2016/11/04/elfutils-memory-allocation-failure-in-__libelf_set_rawdata_wrlock-elf_getdata-c/</preline>
  </pre>
  Fixed in gentoo libelf by Agostino Sarubbo.
</description>

<datefixed>2016-11-04</datefixed>

<references> regressiontests/sarubbo-a/00031-elfutils-memalloc-__libelf_set_rawdata_wrlock
</references>

<gitfixid></gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-9480</cve>

<fuzzer></fuzzer>

<datereported>2016-11-14</datereported>

<reportedby>Puzzor (Shi Ji)</reportedby>

<product>libdwarf</product>

<vulnerability> Heap buffer overflow
</vulnerability>

<description> An object with corrupt contents causes a memory reference
 out of bounds, a heap buffer overflow reference.
 <pre>
<preline> heap-buffer-overflow in dwarf_util.c:208 for val_ptr</preline>
<preline> # Version</preline>
<preline> bb9a3492ac5713bed9cf3ae58ddb7afa6e9e98f8</preline>
<preline> (in regression tests here named  heap_buf_overflow.o)</preline>
<preline> # ASAN Output</preline>
<preline> &lt;0&gt; tag: 17 DW_TAG_compile_unit  name: &quot;strstrnocase.c&quot; FORM 0xe &quot;DW_FORM_strp&quot;</preline>
<preline> &lt;1&gt; tag: 46 DW_TAG_subprogram  name: &quot;is_strstrnocase&quot; FORM 0xe &quot;DW_FORM_strp&quot;</preline>
<preline> =================</preline>
<preline> ==1666==ERROR: AddressSanitizer: heap-buffer-overflow on address</preline>
<preline>   0xb5846db9 at p</preline>
<preline> c 0x080b3a1b bp 0xbfa75d18 sp 0xbfa75d08</preline>
<preline> READ of size 1 at 0xb5846db9 thread T0</preline>
<preline>    #0 0x80b3a1a in _dwarf_get_size_of_val /home/puzzor/libdwarf-code/</preline>
<preline>        libdwarf/dwarf_util.c:208</preline>
<preline>    #1 0x8056602 in _dwarf_next_die_info_ptr /home/puzzor/libdwarf-code/</preline>
<preline>        libdwarf/dwarf_die_deliv.c:1353</preline>
<preline>    #2 0x8057f4b in dwarf_child /home/puzzor/libdwarf-code/libdwarf/</preline>
<preline>       dwarf_die_de liv.c:1688</preline>
<preline>    #3 0x804b5fa in get_die_and_siblings simplereader.c:637</preline>
<preline>    #4 0x804b65c in get_die_and_siblings simplereader.c:643</preline>
<preline>    #5 0x804b3f3 in read_cu_list simplereader.c:611</preline>
<preline>    #6 0x804aeae in main simplereader.c:533</preline>
<preline>    #7 0xb6ffe275 in __libc_start_main (/lib/i386-linux-gnu/libc.so.6+0x18275)</preline>
<preline>    #8 0x80491c0  (/home/puzzor/libdwarf-code/dwarfexample/simplereader+</preline>
<preline>         0x80491c 0)</preline>
<preline> 0xb5846db9 is located 0 bytes to the right of 249-byte region</preline>
<preline>    [0xb5846cc0,0xb5846db9)</preline>
<preline> allocated by thread T0 here:</preline>
<preline>    #0 0xb727fae4 in __interceptor_malloc (/usr/lib/i386-linux-gnu/libasan.so.</preline>
<preline>       3+ 0xc3ae4)</preline>
<preline>    #1 0xb71a9b98  (/usr/lib/i386-linux-gnu/libelf.so.1+0x9b98)</preline>
 </pre>
 For the orignal bug report see
 <pre>
<preline> https://sourceforge.net/p/libdwarf/bugs/5/</preline>
 </pre>
</description>

<datefixed>2016-11-16</datefixed>

<references> regressiontests/puzzor/heap_buf_overflow.o
</references>

<gitfixid>5dd64de047cd5ec479fb11fe7ff2692fd819e5e5</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-9558</cve>

<fuzzer></fuzzer>

<datereported>2016-11-11</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> negation of -9223372036854775808 cannot be represented in type
</vulnerability>

<description> With the right bit pattern in a signed leb number
 the signed leb decode would execute an unary minus with undefined
 effect. This is not known to generate an incorrect value,
 but it could, one supposes.
</description>

<datefixed>2016-11-11</datefixed>

<references> regressiontests/sarubbo-2/00050-libdwarf-negate-itself
</references>

<gitfixid>4f19e1050cd8e9ddf2cb6caa061ff2fec4c9b5f9</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-9275</cve>

<fuzzer></fuzzer>

<datereported>2016-11-02</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> Heap overflow in dwarf_skim_forms()
</vulnerability>

<description> If a non-terminated string
  in a DWARF5 macro section
  ends a section it can result in accessing memory not
  in the application (out of bounds read).
  dwarf_macro5.c(in _dwarf_skim_forms()).
</description>

<datefixed>2016-11-04</datefixed>

<references> regressiontests/sarubbo-2/00027-libdwarf-heapoverflow-_dwarf_skim_forms
</references>

<gitfixid>583f8834083b5ef834c497f5b47797e16101a9a6</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-9276</cve>

<fuzzer></fuzzer>

<datereported>2016-11-02</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> Bad aranges length leads to overflow and bad pointer
</vulnerability>

<description>  in dwarf_arange.c(dwarf_get_aranges_list) an aranges
 header with corrupt data could, with an overflowing calculation,
 result in pointers to invalid or inappropriate memory being
 dereferenced.
</description>

<datefixed>2016-11-04</datefixed>

<references> regressiontests/sarubbo-2/00026-libdwarf-heapoverflow-dwarf_get_aranges_list
</references>

<gitfixid>583f8834083b5ef834c497f5b47797e16101a9a6</gitfixid>

<tarrelease>libdwarf-20170416.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2016-11-02</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> heap overflow in get_attr_value
</vulnerability>

<description> Libdwarf failed to check for a bogus
 length in dwarf_form.c (dwarf_formblock()) resulting
 in a pointer pointing outside of the intended memory
 region.  Anything could happen in the subsequent
 use of the bogus pointer.
 <pre>
<preline> 0x61300000de1c is located 0 bytes to the right of 348-byte region</preline>
<preline> [0x61300000dcc0,0x61300000de1c)</preline>
<preline> allocated by thread T0 here:</preline>
<preline>   #0 0x4c0ad8 in malloc /var/tmp/portage/sys-devel/llvm-3.8.1-</preline>
<preline> r2/work/llvm-3.8.1.src/projects/compiler-rt/lib/asan/asan_malloc_linux.cc:52</preline>
<preline>   #1 0x7f883cfc6206 in __libelf_set_rawdata_wrlock /tmp/portage/dev-</preline>
<preline> libs/elfutils-0.166/work/elfutils-0.166/libelf/elf_getdata.c:318</preline>
 </pre>
</description>

<datefixed>2016-11-04</datefixed>

<references> regressiontests/sarubbo-2/00025-libdwarf-heapoverflow-get_attr_value
</references>

<gitfixid>583f8834083b5ef834c497f5b47797e16101a9a6</gitfixid>

<tarrelease>libdwarf-20170416.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2016-11-02</datereported>

<reportedby>Agostino Sarubbo</reportedby>

<product>libdwarf</product>

<vulnerability> Memory allocation failure in do_decompress_zlib
</vulnerability>

<description> In decompressing a zlib compressed section if
 the decompressed section size is nonsense (too large)
 an attempted malloc will fail and could let an exception
 propagate to callers.
 <pre>
<preline>  ==27994==WARNING: AddressSanitizer failed to allocate 0x62696c2f7273752f</preline>
<preline>  bytes ==27994==AddressSanitizer's allocator is terminating the process</preline>
<preline>  instead of returning 0</preline>
<preline>  ...</preline>
<preline>   #6 0x4c0ab1 in malloc /var/tmp/portage/sys-devel/llvm-3.8.1-</preline>
<preline>   #8 0x5b582e in _dwarf_load_section</preline>
<preline>   #9 0x5bb479 in dwarf_srcfiles</preline>
<preline>   #10 0x5145cd in print_one_die_section</preline>
 </pre>
</description>

<datefixed>2016-11-04</datefixed>

<references> regressiontests/sarubbo-2/00024-libdwarf-memalloc-do_decompress_zlib
</references>

<gitfixid>583f8834083b5ef834c497f5b47797e16101a9a6</gitfixid>

<tarrelease>libdwarf-20170416.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-8679</cve>

<fuzzer></fuzzer>

<datereported>2016-10-02</datereported>

<reportedby>agostino</reportedby>

<product>libdwarf</product>

<vulnerability> dwarf_get_size_of_val out of bounds read
</vulnerability>

<description> The _dwarf_get_size_of_val function in
  libdwarf/dwarf_util.c in Libdwarf before 20161124
  allows remote attackers to cause a denial of service
  (out-of-bounds read) by calling the dwarfdump command
  on a crafted file.
  <pre>
<preline>  www.securityfocus.com/bid/93601</preline>
<preline>  blogs.gentoo.org/ago/2016/10/06/libdwarf-heap-based-</preline>
<preline>  buffer-overflow-in-_dwarf_get_size_of_val-dwarf_util-c/</preline>
  </pre>
</description>

<datefixed>2016-10-04</datefixed>

<references></references>

<gitfixid>efe48cad0693d6994d9a7b561e1c3833b073a624</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-8680</cve>

<fuzzer></fuzzer>

<datereported>2016-10-02</datereported>

<reportedby>agostino</reportedby>

<product>libdwarf</product>

<vulnerability> Out of bounds read
</vulnerability>

<description> The _dwarf_get_abbrev_for_code function in
  dwarf_util.c in libdwarf 20161001 and earlier allows remote
  attackers to cause a denial of service (out-of-bounds read)
  by calling the dwarfdump command on a crafted file.
  <pre>
<preline>  bugzilla.redhat.com/show_bug.cgi?id=1385690</preline>
<preline>  www.securityfocus.com/bid/93592</preline>
<preline>  Duplicate of CVE-2016-8681</preline>
  </pre>
</description>

<datefixed>2016-10-04</datefixed>

<references></references>

<gitfixid>efe48cad0693d6994d9a7b561e1c3833b073a624</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-8681</cve>

<fuzzer></fuzzer>

<datereported>2016-10-02</datereported>

<reportedby>agostino</reportedby>

<product>libdwarf</product>

<vulnerability> Out of bounds read
</vulnerability>

<description> The _dwarf_get_abbrev_for_code function in
  dwarf_util.c in libdwarf 20161001 and earlier allows remote
  attackers to cause a denial of service (out-of-bounds read)
  by calling the dwarfdump command on a crafted file.
  <pre>
<preline>  bugzilla.redhat.com/show_bug.cgi?id=1385690</preline>
<preline>  www.securityfocus.com/bid/93592</preline>
<preline>  Duplicate of CVE-2016-8680</preline>
  </pre>
</description>

<datefixed>2016-10-04</datefixed>

<references></references>

<gitfixid>efe48cad0693d6994d9a7b561e1c3833b073a624</gitfixid>

<tarrelease></tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-7510</cve>

<fuzzer></fuzzer>

<datereported>2016-09-17</datereported>

<reportedby>Puzzor</reportedby>

<product>libdwarf</product>

<vulnerability> libdwarf 20160613 Out-of-Bounds read
</vulnerability>

<description>  read line table program Out-of-Bounds read
 line_ptr in dwarf_line_table_reader_common.c:1433 Out-of-Bounds read
 See:
 <pre>
<preline> https://bugzilla.redhat.com/show_bug.cgi?id=1377015</preline>
<preline> https://sourceforge.net/p/libdwarf/bugs/4/</preline>
 </pre>
 <pre>
<preline> # Address Sanitizer Output</preline>
<preline> ==27763==ERROR: AddressSanitizer: heap-buffer-overflow on address 0xf4603f84 at pc 0x8408ede bp 0xffff6518 sp 0xffff6510</preline>
<preline> READ of size 1 at 0xf4603f84 thread T0</preline>
<preline> #0 0x8408edd in read_line_table_program /home/puzzor/test-fuzzing/code/libdwarf/./dwarf_line_table_reader_common.c:1433</preline>
<preline> #1 0x83f716c in _dwarf_internal_srclines /home/puzzor/test-fuzzing/code/libdwarf/./dwarf_line.c:690</preline>
<preline> #2 0x841436c in dwarf_srclines_b /home/puzzor/test-fuzzing/code/libdwarf/./dwarf_line.c:944</preline>
<preline> #3 0x81fbc28 in print_line_numbers_this_cu /home/puzzor/test-fuzzing/code/dwarfdump/print_lines.c:763</preline>
<preline> #4 0x815c191 in print_one_die_section /home/puzzor/test-fuzzing/code/dwarfdump/print_die.c:850</preline>
<preline> #5 0x81565c1 in print_infos /home/puzzor/test-fuzzing/code/dwarfdump</preline>
 </pre>
</description>

<datefixed>2016-09-23</datefixed>

<references> regressiontests/DW201609-004/poc
</references>

<gitfixid>3767305debcba8bd7e1c483ae48c509d25399252</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-7410</cve>

<fuzzer></fuzzer>

<datereported>2016-09-13</datereported>

<reportedby>https://marc.info/?l=oss-security&amp;m=147391785920048&amp;w=2</reportedby>

<product>libdwarf</product>

<vulnerability> libdwarf 20160613 heap-buffer-overflow
</vulnerability>

<description> With AddressSanitizer,
  we found a Heap-Buffer-overflow in the latest
  release version of dwarfdump. The crash output is as follows:
  <pre>
<preline>  See also:</preline>
<preline>  https://marc.info/?l=oss-security&amp;m=147378394815872&amp;w=2</preline>
<preline>  The testcase poc is from this web page.</preline>
  </pre>
  <pre>
<preline>  ==17411==ERROR: AddressSanitizer: heap-buffer-overflow on address</preline>
<preline>  0xf3808904 at pc 0x80a6f76 bp 0xffb95e78 sp 0xffb95a5c</preline>
<preline>  READ of size 4 at 0xf3808904 thread T0</preline>
<preline>  ==17411==WARNING: Trying to symbolize code, but external symbolizer is</preline>
<preline>  not initialized!</preline>
<preline>    #0 0x80a6f75 in __interceptor_memcpy ??:?</preline>
<preline>    #1 0x8426c3b in _dwarf_read_loc_section</preline>
<preline>  /home/starlab/fuzzing/dwarf-20160613/libdwarf/./dwarf_loc.c:919</preline>
<preline>    #2 0x84250e2 in _dwarf_get_loclist_count</preline>
<preline>  /home/starlab/fuzzing/dwarf-20160613/libdwarf/./dwarf_loc.c:970</preline>
<preline>    #3 0x8438826 in dwarf_get_loclist_c</preline>
<preline>  /home/starlab/fuzzing/dwarf-20160613/libdwarf/./dwarf_loc2.c:551</preline>
<preline>    #4 0x81a1be8 in get_location_list</preline>
<preline>  /home/starlab/fuzzing/dwarf-20160613/dwarfdump/print_die.c:3523</preline>
<preline>    #5 0x816e1a2 in print_attribute</preline>
  </pre>
  _dwarf_get_loclist_header_start() is not cautious about values
  in the header being absurdly large.
  Unclear as yet if this is the problem
  but it is a potential problem (fixed for next release).
  <pre>
<preline>  Address Sanitizer in gcc reproduces the report.</preline>
<preline>  In _dwarf_read_loc_section() the simple calculation of</preline>
<preline>  loc_section_end was wrong, so end-of section was</preline>
<preline>  incorrect for the local reads.</preline>
<preline>  With that fixed we get DW_DLE_READ_LITTLEENDIAN_ERROR when</preline>
<preline>  libdwarf attempts to read off end of section.</preline>
  </pre>
</description>

<datefixed>2016-09-23</datefixed>

<references> regressiontests/DW201609-003/poc
</references>

<gitfixid>3767305debcba8bd7e1c483ae48c509d25399252</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-7511</cve>

<fuzzer></fuzzer>

<datereported>2016-09-18</datereported>

<reportedby>Shi Ji (@Puzzor)</reportedby>

<product>libdwarf</product>

<vulnerability> libdwarf 20160613 Integer Overflow
</vulnerability>

<description> In dwarf_get_size_of_val() with
  fuzzed DWARF data we get a SEGV.
  <pre>
<preline>  See</preline>
<preline>  https://sourceforge.net/p/libdwarf/bugs/3/</preline>
  </pre>
  <pre>
<preline>  ==6825== ERROR: AddressSanitizer: SEGV on unknown address 0x0583903c (pc 0xb61f1a98 sp 0xbfa388b4 bp 0xbfa38d08 T0)</preline>
<preline>  AddressSanitizer can not provide additional info.</preline>
<preline>  #1 0xb61e3c0b (/usr/lib/i386-linux-gnu/libasan.so.0+0xdc0b)</preline>
<preline>  #2 0x80a21b1 in _dwarf_get_size_of_val /home/fuzzing/fuzzing/dwarf-20160613/libdwarf/dwarf_util.c:210</preline>
<preline>  #3 0x8054214 in _dwarf_next_die_info_ptr /home/fuzzing/fuzzing/dwarf-20160613/libdwarf/dwarf_die_deliv.c:1340</preline>
<preline>  #4 0x80557a5 in dwarf_child /home/fuzzing/fuzzing/dwarf-20160613/libdwarf/dwarf_die_deliv.c:1640</preline>
<preline>  #5 0x804b23f in get_die_and_siblings /home/fuzzing/fuzzing/dwarf-20160613/dwarfexample/./simplereader.c:573</preline>
  </pre>
  _dwarf_make_CU_Context() is insufficiently cautious about
  the length of a CU being absurd.
  Unclear as yet if this is the problem
  but it is a problem and is fixed for next release.
</description>

<datefixed>2016-09-23</datefixed>

<references> regressiontests/DW201609-002/DW201609-002-poc
</references>

<gitfixid>3767305debcba8bd7e1c483ae48c509d25399252</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2016-09-16</datereported>

<reportedby>STARLAB</reportedby>

<product>libdwarf</product>

<vulnerability> libdwarf 20160613 die_info_ptr in dwarf_die_deliv.c: 1533 Out-Of_bounds
</vulnerability>

<description> At line 1533 of dwarf_die_deliv.c a
 pointer dereference is done with a pointer pointing
 past the end of the CU data.
 <pre>
<preline> see</preline>
<preline> https://sourceforge.net/p/libdwarf/bugs/2/</preline>
 </pre>
 <pre>
<preline> ==8054==ERROR: AddressSanitizer: heap-buffer-overflow on</preline>
<preline>    address 0xf4c027ab at pc 0x819e4a4 bp 0xff88eb38 sp 0xff88eb30</preline>
<preline> READ of size 1 at 0xf4c027ab thread T0</preline>
<preline> #0 0x819e4a3 in dwarf_siblingof_b /home/starlab/fuzzing/dwarf-20160613/libdwarf/dwarf_die_deliv.c:1533</preline>
<preline> #1 0x8116201 in print_die_and_children_internal /home/starlab/fuzzing/dwarf-20160613/dwarfdump/print_die.c:1157</preline>
<preline> Bug report on sourceforge.net bug list for libdwarf.</preline>
<preline> The bad pointer dereference is due to libdwarf</preline>
<preline> not noticing that the DWARF in that file is corrupt.</preline>
<preline> In addtion</preline>
<preline> The code was not noticing that it could dereference</preline>
<preline> a pointer that pointed out of bounds in the end-sibling-list</preline>
<preline> loop.</preline>
 </pre>
 <pre>
<preline> The example from the bug report (DW201609-001-poc) has</preline>
<preline> the same problem.</preline>
<preline> dwarfdump now reports DW_DLE_SIBLING_LIST_IMPROPER</preline>
<preline> on both test2.o and DW201609-001-poc.</preline>
 </pre>
</description>

<datefixed>2016-09-17</datefixed>

<references> regressiontests/DW201609-001/test2.o
  regressiontests/DW201609-001/DW201609-001-poc
</references>

<gitfixid>3767305debcba8bd7e1c483ae48c509d25399252</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5027</cve>

<fuzzer></fuzzer>

<datereported>2016-04-25</datereported>

<reportedby>Yue Liu,lieanu</reportedby>

<product>libdwarf</product>

<vulnerability> NULL dereference in  _dwarf_decode_s_leb128
</vulnerability>

<description> dwarf_form.c in libdwarf 20160115 allows
  remote attackers to cause a denial of service (crash)
  via a crafted elf file
  Apparently no crafted object file presented.
  However the code fix is presented in the report
  at openwall.com.
  Discovered the CVE November 2021
  To attack the code just pass the argument
  Dwarf_Word * leb128_length as a NULL pointer (that is allowed).
  The code was fixed in dwarf_leb.c on 2016-04-27 20:00:06.
  <pre>
<preline>  bugzilla.redhat.com/show_bug.cgi?id=1330237</preline>
<preline>  www.openwall.com/lists/oss-security/2016/05/24/1</preline>
<preline>  www.openwall.com/lists/oss-security/2016/05/25/1</preline>
  </pre>
</description>

<datefixed>2016-05-27</datefixed>

<references></references>

<gitfixid></gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5028</cve>

<fuzzer></fuzzer>

<datereported>2016-05-23</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> Null dereference in print_frame_inst_bytes (dwarfdump)
</vulnerability>

<description> The null dereference is due to a corrupted
 object file. Libdwarf was not dealing with empty (bss-like)
 sections since it really did not expect to see such in
 sections it reads!  Now libdwarf catches the object error
 so dwarfdump sees the section as empty (as indeed it is!).
</description>

<datefixed>2016-05-23</datefixed>

<references> regressiontests/liu/NULLdeference0522c.elf
</references>

<gitfixid>a55b958926cc67f89a512ed30bb5a22b0adb10f4</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5029</cve>

<fuzzer></fuzzer>

<datereported>2016-05-22</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> Null dereference in create_fullest_file_path().
</vulnerability>

<description> The null dereference in create_fullest_file_path()
 causes a crash. This is due to corrupted dwarf and the fix
 detects this corruption and if that null string pointer
 happens undetected a static string is substituted so
 readers can notice the situation.
 <pre>
<preline>  202             }</preline>
<preline> 203             if (dirno &gt; 0 &amp;&amp; fe-&gt;fi_dir_index &gt; 0) {</preline>
<preline> 204                 inc_dir_name = (char *)</preline>
<preline>                         line_context-&gt;lc_include_directories[</preline>
<preline> 205                     fe-&gt;fi_dir_index - 1];</preline>
<preline> 206                 incdirnamelen = strlen(inc_dir_name);  &lt;- $pc</preline>
<preline> 207             }</preline>
<preline> 208             full_name = (char *) _dwarf_get_alloc(dbg,</preline>
<preline> #0  create_fullest_file_path (dbg=&lt;optimized out&gt;,</preline>
<preline> fe=0x68d510, line_context=0x68c4f0, name_ptr_out=&lt;optimized</preline>
<preline> out&gt;, error=0x7fffffffe2b8) at ./dwarf_line.c:206</preline>
<preline> #1  0x00007ffff7b6d3f9 in dwarf_filename (context=&lt;optimized</preline>
<preline> out&gt;, fileno_in=&lt;optimized out&gt;, ret_filename=0x7fffffffe280,</preline>
<preline> error=0x7fffffffe2b8) at ./dwarf_line.c:1418</preline>
<preline> #2  dwarf_linesrc (line=&lt;optimized out&gt;,</preline>
<preline> ret_linesrc=&lt;optimized out&gt;, error=&lt;optimized out&gt;) at</preline>
<preline> ./dwarf_line.c:1436</preline>
 </pre>
</description>

<datefixed>2016-05-22</datefixed>

<references> regressiontests/liu/NULLdereference0522.elf
</references>

<gitfixid>acae971371daa23a19358bc62204007d258fbc5e</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5030</cve>

<fuzzer></fuzzer>

<datereported>2016-05-19</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> Null dereference bug in  _dwarf_calculate_info_section_end_ptr().
</vulnerability>

<description> NULL dereference bug in _dwarf_calculate_info_section_end_ptr().
 <pre>
<preline> 1742         Dwarf_Off off2 = 0;</preline>
<preline> 1743         Dwarf_Small *dataptr = 0;</preline>
<preline> 1744</preline>
<preline> 1745         dbg = context-&gt;cc_dbg;</preline>
<preline> 1746         dataptr = context-&gt;cc_is_info? dbg-&gt;de_debug_info.dss_data:                 &lt;- $pc</preline>
<preline> 1747             dbg-&gt;de_debug_types.dss_data;</preline>
<preline> 1748         off2 = context-&gt;cc_debug_offset;</preline>
<preline> 1749         info_start = dataptr + off2;</preline>
<preline> 1750         info_end = info_start + context-&gt;cc_length +</preline>
<preline> #0  _dwarf_calculate_info_section_end_ptr</preline>
<preline> (context=context@entry=0x0) at dwarf_query.c:1746</preline>
<preline> #1  0x00002aaaaace307d in</preline>
<preline> _dwarf_extract_string_offset_via_str_offsets</preline>
<preline> (dbg=dbg@entry=0x655a70, info_data_ptr=0x6629f0</preline>
<preline> &quot;&quot;, attrnum=attrnum@entry=121,</preline>
<preline> attrform=attrform@entry=26, cu_context=0x0,</preline>
<preline> str_sect_offset_out=str_sect_offset_out@entry=0x7fffffffd718,</preline>
<preline> error=error@entry=0x7fffffffd878) at dwarf_form.c:1099</preline>
<preline> #2  0x00002aaaaacf4ed7 in dwarf_get_macro_defundef</preline>
<preline> (macro_context=macro_context@entry=0x65b790,</preline>
<preline> op_number=op_number@entry=1,</preline>
<preline> line_number=line_number@entry=0x7fffffffd858,</preline>
<preline> index=index@entry=0x7fffffffd860,</preline>
<preline> offset=offset@entry=0x7fffffffd868,</preline>
<preline> forms_count=forms_count@entry=0x7fffffffd7ce,</preline>
<preline> macro_string=macro_string@entry=0x7fffffffd870,</preline>
<preline> error=error@entry=0x7fffffffd878) at dwarf_macro5.c:557</preline>
<preline> ------</preline>
<preline> _dwarf_calculate_info_section_end_ptr (context=context@entry=0x0) at</preline>
<preline>   dwarf_query.c:1746</preline>
<preline> 1746        dataptr = context-&gt;cc_is_info? dbg-&gt;de_debug_info.dss_data:</preline>
<preline> gef&gt; p/x $rdi</preline>
<preline> $4 = 0x0</preline>
 </pre>
</description>

<datefixed>2016-05-22</datefixed>

<references> regressiontests/liu/NULLdereference0519.elf
</references>

<gitfixid>6fa3f710ee6f21bba7966b963033a91d77c952bd</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2016-05-19</datereported>

<reportedby>Yue Liu</reportedby>

<product>dwarfdump</product>

<vulnerability> Invalid dwarf leads to
 dwarfdump crash in print_frame_inst_bytes.
</vulnerability>

<description> Corrupted dwarf crashes dwarfdump
 <pre>
<preline> 1297         }</preline>
<preline> 1298         len = len_in;</preline>
<preline> 1299         endpoint = instp + len;</preline>
<preline> 1300         for (; len &gt; 0;) {</preline>
<preline> 1301             unsigned char ibyte = *instp;           &lt;- $pc</preline>
<preline> 1302             int top = ibyte &amp; 0xc0;</preline>
<preline> 1303             int bottom = ibyte &amp; 0x3f;</preline>
<preline> 1304             int delta = 0;</preline>
<preline> 1305             int reg = 0;</preline>
<preline> #0  print_frame_inst_bytes (dbg=dbg@entry=0x655ca0,</preline>
<preline> cie_init_inst=&lt;optimized out&gt;, len_in=&lt;optimized out&gt;,</preline>
<preline> data_alignment_factor=-4, code_alignment_factor=4,</preline>
<preline> addr_size=addr_size@entry=4, offset_size=4, version=3,</preline>
<preline> config_data=config_data@entry=0x63cda0 &lt;g_config_file_data&gt;)</preline>
<preline> at print_frames.c:1301</preline>
<preline> #1  0x000000000041b70c in print_one_cie</preline>
<preline> (dbg=dbg@entry=0x655ca0, cie=&lt;optimized out&gt;,</preline>
<preline> cie_index=cie_index@entry=2, address_size=&lt;optimized out&gt;,</preline>
<preline> config_data=config_data@entry=0x63cda0 &lt;g_config_file_data&gt;)</preline>
<preline> at print_frames.c:1161</preline>
<preline> #2  0x000000000041cf52 in print_frames (dbg=0x655ca0,</preline>
<preline> print_debug_frame=print_debug_frame@entry=1, print_eh_frame=0,</preline>
<preline> config_data=config_data@entry=0x63cda0 &lt;g_config_file_data&gt;)</preline>
<preline> at print_frames.c:2229</preline>
<preline> gef&gt; p/x $r13</preline>
<preline> $1 = 0x4bcad8</preline>
<preline> gef&gt; p/x *$r13</preline>
<preline> Cannot access memory at address 0x4bcad8</preline>
 </pre>
</description>

<datefixed>2016-05-22</datefixed>

<references> regressiontests/liu/OOB_READ0519.elf
</references>

<gitfixid>6fa3f710ee6f21bba7966b963033a91d77c952bd</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5031</cve>

<fuzzer></fuzzer>

<datereported>2016-05-17</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> OOB read bug in print_frame_inst_bytes()
</vulnerability>

<description> Test object shows
 an invalid read in  print_frame_inst_bytes().
 <pre>
<preline> 1294         for (; len &gt; 0;) {</preline>
<preline> 1295             unsigned char ibyte = *instp;           &lt;- $pc</preline>
<preline> 1296             int top = ibyte &amp; 0xc0;</preline>
<preline> #0  print_frame_inst_bytes (dbg=dbg@entry=0x654c80,</preline>
<preline>    cie_init_inst=&lt;optimized out&gt;, len=503715, data_alignment_factor=-4,</preline>
<preline>    code_alignment_factor=1, addr_size=addr_size@entry=4, offset_size=4,</preline>
<preline>    version=3, config_data=config_data@entry=0x63bda0</preline>
<preline>    &lt;g_config_file_data&gt;) at print_frames.c:1295</preline>
<preline> #1  0x000000000041b64c in print_one_cie (dbg=dbg@entry=0x654c80,</preline>
<preline>    cie=&lt;optimized out&gt;, cie_index=cie_index@entry=1,</preline>
<preline>    address_size=&lt;optimized out&gt;, config_data=</preline>
<preline>    config_data@entry=0x63bda0 &lt;g_config_file_data&gt;) at print_frames.c:1161</preline>
<preline> #2  0x000000000041ce92 in print_frames (dbg=0x654c80,</preline>
<preline>    print_debug_frame=print_debug_frame@entry=1, print_eh_frame=0,</preline>
<preline>    config_data=config_data@entry=0x63bda0 &lt;g_config_file_data&gt;)</preline>
<preline>    at print_frames.c:2209</preline>
<preline> gef&gt; x/10x $r13</preline>
<preline> 0x5e7981:       Cannot access memory at address 0x5e7981</preline>
<preline> gef&gt; p/x $r13</preline>
<preline> $14 = 0x5e7981</preline>
 </pre>
</description>

<datefixed>2015-05-18</datefixed>

<references> regressiontests/liu/OOB0517_03.elf
</references>

<gitfixid>ac6673e32f3443a5d36c2217cb814000930b2c54</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5032</cve>

<fuzzer></fuzzer>

<datereported>2016-05-17</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> OOB read bug in dwarf_get_xu_hash_entry()
</vulnerability>

<description> Test object shows
 an invalid read in dwarf_get _xu_hash_entry, lin 211.
 <pre>
<preline> #0  dwarf_get_xu_hash_entry (xuhdr=xuhdr@entry=0x657360,</preline>
<preline>    index=index@entry=2897626028, hash_value=</preline>
<preline>    hash_value@entry=0x7fffffffd5b0,</preline>
<preline>    index_to_sections=index_to_sections@entry=0x7fffffffd5a8,</preline>
<preline>    err=err@entry=0x7fffffffdb08) at dwarf_xu_index.c:211</preline>
<preline> #1  0x00002aaaaacfd05e in _dwarf_search_fission_for_key (</preline>
<preline>    dbg=0x654a50, error=0x7fffffffdb08, percu_index_out=&lt;synthetic pointer&gt;,</preline>
<preline>    key_in=0x7fffffffd670, xuhdr=0x657360) at dwarf_xu_index.c:363</preline>
<preline> #2  dwarf_get_debugfission_for_key (dbg=dbg@entry=0x654a50,</preline>
<preline>    key=key@entry=0x7fffffffd670, key_type=key_type@entry=0x2aaaaad15e2a</preline>
<preline>    &quot;tu&quot;, percu_out=percu_out@entry=0x65a830,</preline>
<preline>    error=error@entry=0x7fffffffdb08) at dwarf_xu_index.c:577</preline>
 </pre>
</description>

<datefixed>2015-05-18</datefixed>

<references> regressiontests/liu/OOB0517_02.elf
</references>

<gitfixid>ac6673e32f3443a5d36c2217cb814000930b2c54</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5033</cve>

<fuzzer></fuzzer>

<datereported>2016-05-17</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> OOB read bug in print_exprloc_content
</vulnerability>

<description> Test object shows
 an invalid write in print_exprloc_content.
 <pre>
<preline> #0  print_exprloc_content (dbg=dbg@entry=0x654ea0,</preline>
<preline>    die=die@entry=0x65b110, attrib=attrib@entry=0x65b590,</preline>
<preline>    esbp=esbp@entry=0x7fffffffcef0, showhextoo=1) at print_die.c:4182</preline>
<preline> #1  0x0000000000412fb1 in get_attr_value (dbg=dbg@entry=0x654ea0,</preline>
<preline>    tag=&lt;optimized out&gt;, die=die@entry=0x65b110,</preline>
<preline>    dieprint_cu_goffset=dieprint_cu_goffset@entry=11,</preline>
<preline>    attrib=attrib@entry=0x65b590, srcfiles=srcfiles@entry=0x0,</preline>
<preline>    cnt=cnt@entry=0, esbp=esbp@entry=0x7fffffffcef0, show_form=0,</preline>
<preline>    local_verbose=0) at print_die.c:4972</preline>
 </pre>
</description>

<datefixed>2015-05-18</datefixed>

<references> regressiontests/liu/OOB0517_01.elf
</references>

<gitfixid>ac6673e32f3443a5d36c2217cb814000930b2c54</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5034</cve>

<fuzzer></fuzzer>

<datereported>2016-05-13</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> OOB write. From relocation records
</vulnerability>

<description> Test object shows
 an invalid write in dwarf_elf_access.c
 (when doing the relocations).
 Adding the relocation value to anything overflowed
 and disguised the bad relocation record.
 With a 32bit kernel build the test could show
 a double-free and coredump due to the unchecked invalid
 writes from relocations.
</description>

<datefixed>2016-05-17</datefixed>

<references> regressiontests/liu/HeapOverflow0513.elf
</references>

<gitfixid>10ca310f64368dc083efacac87732c02ef560a92</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5035</cve>

<fuzzer></fuzzer>

<datereported>2016-05-06</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> OOB read bug in _dwarf_read_line_table_header
</vulnerability>

<description> Test object shows
 null dereference at line 62
 of dwarf_line_table_reader.c.
 Frame code and linetable code was not noticing data corruption.
</description>

<datefixed>2016-05-12</datefixed>

<references> regressiontests/liu/OOB_read4.elf
</references>

<gitfixid>82d8e007851805af0dcaaff41f49a2d48473334b</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5036</cve>

<fuzzer></fuzzer>

<datereported>2016-05-06</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> OOB read bug in dump_block
</vulnerability>

<description> Test object shows
 null dereverence at line 186
 of dump_block() in print_sections.c
 Frame code was not noticing frame data corruption.
</description>

<datefixed>2016-05-12</datefixed>

<references> regressiontests/liu/OOB_read3.elf
 regressiontests/liu/OOB_read3_02.elf
</references>

<gitfixid>82d8e007851805af0dcaaff41f49a2d48473334b</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5037</cve>

<fuzzer></fuzzer>

<datereported>2016-05-05</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> NULL dereference in _dwarf_load_section
</vulnerability>

<description> Test object shows
 null dereverence at line 1010
 if(!strncmp(&quot;ZLIB&quot;,(const char *)src,4)) {
 in dwarf_init_finish.c
 The zlib code was not checking for
 a corrupted length-value.
</description>

<datefixed>2016-05-06</datefixed>

<references> regressiontests/liu/NULLderefer0505_01.elf
</references>

<gitfixid>b6ec2dfd850929821626ea63fb0a752076a3c08a</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5038</cve>

<fuzzer></fuzzer>

<datereported>2016-05-05</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> OOB read in dwarf_get_macro_startend_file()
</vulnerability>

<description> Test object shows
 out of bound read.
 OOB at:
 line 772  *src_file_name = macro_context-&gt;mc_srcfiles[trueindex];
 in dwarf_macro5.c
 A string offset into .debug_str is outside the bounds
 of the .debug_str section.
</description>

<datefixed>2016-05-12</datefixed>

<references> regressiontests/liu/OOB0505_02.elf
 regressiontests/liu/OOB0505_02_02.elf
</references>

<gitfixid>82d8e007851805af0dcaaff41f49a2d48473334b</gitfixid>

<tarrelease>libdwarf-20160923.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5039</cve>

<fuzzer></fuzzer>

<datereported>2016-05-05</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> OOB read bug in get_attr_value()
</vulnerability>

<description> Test object shows
 out of bound read.
 Object had data all-bits-on so
 the existing length check did not work
 due to wraparound. Added a check
 not susceptible to that error (DW_DLE_FORM_BLOCK_LENGTH_ERROR).
</description>

<datefixed>2016-05-06</datefixed>

<references> regressiontests/liu/OOB0505_01.elf
</references>

<gitfixid>eb1472afac95031d0c9dd8c11d527b865fe7deb8</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve></cve>

<fuzzer></fuzzer>

<datereported>2016-05-05</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> Two Heap-Overflow bug
</vulnerability>

<description> Two test objects showing
 a heap overflow in libdwarf when
 using dwarfdump.
 It seems that these were fixed
 by the previous git update.
 Neither gdb nor valgrind find any errors
 when building with yesterday's commit.
</description>

<datefixed>2016-05-04</datefixed>

<references> regressiontests/liu/free_invalid_address.elf
 regressiontests/liu/heapoverflow01b.elf
</references>

<gitfixid>98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5040</cve>

<fuzzer></fuzzer>

<datereported>2016-05-02</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> A specially crafted DWARF section
 results in  reading a compilation unit header
 that crashes the application.
</vulnerability>

<description> If the data read for a compilation unit header
 contains a too large length value the library
 will read outside of its bounds and crash the application.
</description>

<datefixed>2016-05-04</datefixed>

<references> regressiontests/liu/null02.elf
 <pre>
<preline> https://bugzilla.redhat.com/show_bug.cgi?id=1332149</preline>
 </pre>
</references>

<gitfixid>98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5041</cve>

<fuzzer></fuzzer>

<datereported>2016-05-02</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> A specially crafted DWARF section
 results in a null dereference reading debugging
 information entries  which
 crashes the application.
</vulnerability>

<description> If no DW_AT_name is present in a debugging
 information entry  using DWARF5 macros
 a null dereference in dwarf_macro5.c will
 crash the application.
</description>

<datefixed>2016-05-04</datefixed>

<references> regressiontests/liu/null01.elf
 <pre>
<preline> https://bugzilla.redhat.com/show_bug.cgi?id=1332148</preline>
 </pre>
</references>

<gitfixid>98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5042</cve>

<fuzzer></fuzzer>

<datereported>2016-05-02</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> A specially crafted DWARF section
 results in an infinite loop that eventually
 crashes the application.
</vulnerability>

<description> In dwarf_get_aranges_list()
 an invalid count will iterate, reading from memory
 addresses that increase till it all fails.
</description>

<datefixed>2016-05-04</datefixed>

<references> regressiontests/liu/infiniteloop.elf
 <pre>
<preline> https://bugzilla.redhat.com/show_bug.cgi?id=1332145</preline>
 </pre>
</references>

<gitfixid>98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5043</cve>

<fuzzer></fuzzer>

<datereported>2016-05-02</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> A specially crafted DWARF section
 results in a read outside the bounds of in memory
 data so the calling application can crash.
</vulnerability>

<description> Out of bound read bug in libdwarf git code.
 dwarf_dealloc() did not check the Dwarf_Ptr space argument
 before using it. This will lead to a out-of-bound read bug.
 <pre>
<preline> backtrace:</preline>
<preline> #0  dwarf_dealloc (dbg=dbg@entry=0x655f30, space=0xa0,</preline>
<preline> alloc_type=alloc_type@entry=1) at dwarf_alloc.c:477</preline>
<preline> #1  0x00002aaaaacf3296 in dealloc_srcfiles</preline>
<preline> (dbg=0x655f30, srcfiles=0x66b8f0, srcfiles_count=17) at</preline>
<preline> dwarf_macro5.c:1025 #2  0x00002aaaaacf50e6 in dealloc_srcfiles</preline>
<preline> (srcfiles_count=&lt;optimized out&gt;, srcfiles=&lt;optimized out&gt;,</preline>
<preline> dbg=&lt;optimized out&gt;) at dwarf_macro5.c:1021 -----</preline>
<preline> gef&gt; p &amp;r-&gt;rd_dbg</preline>
<preline> $14 = (void **) 0x90</preline>
 </pre>
</description>

<datefixed>2016-05-04</datefixed>

<references> regressiontests/liu/outofbound01.elf
 <pre>
<preline> https://bugzilla.redhat.com/show_bug.cgi?id=1332144</preline>
 </pre>
</references>

<gitfixid>98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-5044</cve>

<fuzzer></fuzzer>

<datereported>2016-05-02</datereported>

<reportedby>Yue Liu</reportedby>

<product>libdwarf</product>

<vulnerability> A specially crafted DWARF section
 results in a duplicate free() in libdwarf and
 the calling application will crash.
</vulnerability>

<description> In file dwarf_elf_access.c:1071
 <pre>
<preline> WRITE_UNALIGNED(dbg,target_section + offset,</preline>
<preline>     &amp;outval,sizeof(outval),reloc_size);</preline>
 </pre>
 A crafted ELF file may lead to a large offset value, which
 bigger than the size of target_section heap chunk, then this
 WRITE_UNALIGNED() function will write the value of &amp;outval
 out of the heap chunk.
 offset is a 64bit unsigned int value, so this is more than
 a heap overflow bug, but also a Out-of-Bound write bug.
 So WRITE_UNALIGNED() need more strictly checking to prevent
 this.
</description>

<datefixed>2016-05-04</datefixed>

<references> regressiontests/liu/heapoverflow01.elf
 <pre>
<preline> https://bugzilla.redhat.com/show_bug.cgi?id=1332141</preline>
 </pre>
</references>

<gitfixid>98a3da1e8237fe0d45b67ef77f3fa5ed9ff0215f</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-2050</cve>

<fuzzer></fuzzer>

<datereported>2016-01-19</datereported>

<reportedby>Qixue Xiao</reportedby>

<product>libdwarf</product>

<vulnerability> Out of bound write in get_abbrev_array_info
</vulnerability>

<description> Crashes the calling program. Requires
  a crafted object file.
  <pre>
<preline>  valgrind ./dwarfdump -ka aw.elf</preline>
<preline>  ==5358== Memcheck, a memory error detector</preline>
<preline>  ==5358== Copyright (C) 2002-2013, and GNU GPL'd, by Julian Seward et al.</preline>
<preline>  ==5358== Using Valgrind-3.10.1 and LibVEX; rerun with -h for copyright info</preline>
<preline>  ==5358== Command: ../../llvm-codes/dwarf-20151114/dwarfdump/dwarfdump -ka aw.elf</preline>
<preline>  ==5358==</preline>
<preline>  ==5358== Invalid write of size 8</preline>
<preline>  ==5358==    at 0x40DA25: get_abbrev_array_info (in</preline>
<preline>  /home/xqx/test/libdwarf-test/llvm-codes/dwarf-20151114/dwarfdump/dwarfdump)</preline>
<preline>  ==5358==    by 0x40FD92: print_one_die_section (in</preline>
<preline>  /home/xqx/test/libdwarf-test/llvm-codes/dwarf-20151114/dwarfdump/dwarfdump)</preline>
<preline>  www.openwall.com/lists/oss-security/2016/01/19/9</preline>
<preline>  www.openwall.com/lists/oss-security/2016/01/25/3</preline>
  </pre>
</description>

<datefixed>2016-01-21</datefixed>

<references> regressiontests/xqx-b/aw.elf
</references>

<gitfixid>d9d40e4d802e626065ce37ff384dd69c43bc499</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2016-2091</cve>

<fuzzer></fuzzer>

<datereported>2016-01-12</datereported>

<reportedby>Qixue Xiao</reportedby>

<product>libdwarf</product>

<vulnerability> Out of bound read in  dwarf_read_cie_fde_prefix()
</vulnerability>

<description> Crashes the calling program. Requires
  a crafted object file.
  <pre>
<preline>  *** DWARF CHECK: DW_DLE_DEBUG_FRAME_LENGTH_NOT_MULTIPLE</preline>
<preline>  len=0x00000010, len size=0x00000004, extn size=0x00000000, totl</preline>
<preline>  length=0x00000014, addr size=0x00000008, mod=0x00000004 must be zero</preline>
<preline>  in cie, offset 0x00000000. ***</preline>
<preline>  7   ==53495== Invalid read of size 2</preline>
<preline>  1 ==53495==    at 0x4C2F7E0: memcpy@@GLIBC_2.14 (in</preline>
<preline>  /usr/lib/valgrind/vgpreload_memcheck-amd64-linux.so)</preline>
<preline>  2 ==53495==    by 0x43287F: dwarf_read_cie_fde_prefix (dwarf_frame2.c:934)</preline>
<preline>  3 ==53495==    by 0x431305: _dwarf_get_fde_list_internal (dwarf_frame2.c:268)</preline>
<preline>  4 ==53495==    by 0x42EB5F: dwarf_get_fde_list_eh (dwarf_frame.c:1101)</preline>
<preline>  5 ==53495==    by 0x41BABE: print_frames (print_frames.c:1835)</preline>
<preline>  6 ==53495==    by 0x40485B: process_one_file (dwarfdump.c:1323)</preline>
<preline>  7 ==53495==    by 0x403529: main (dwarfdump.c:630)</preline>
<preline>  www.openwall.com/lists/oss-security/2016/01/19/3</preline>
<preline>  www.openwall.com/lists/oss-security/2016/05/28/8</preline>
  </pre>
</description>

<datefixed>2016-01-21</datefixed>

<references> regressiontests/xqx-b/awbug5.elf
</references>

<gitfixid>d9d40e4d802e626065ce37ff384dd69c43bc499</gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2015-8538</cve>

<fuzzer></fuzzer>

<datereported>2015-12-14</datereported>

<reportedby>Adam Maris</reportedby>

<product>libdwarf</product>

<vulnerability>  Out-of-bounds read in dwarf_leb.c
</vulnerability>

<description> libdwarf 20151114 and earlier allows remote
  attackers to cause a denial of service (NULL pointer
  dereference and crash) via a debug_abbrev
  section marked NOBITS in an ELF file.
  The CVE report mentions a reproducer object file
  but such is not present.
  Due to recent tool advances (like
  coverity scan) we are confident this was fixed long ago.
  <pre>
<preline>  bugzilla.redhat.com/show_bug.cgi?id=1291299</preline>
<preline>  www.openwall.com/lists/oss-security/2015/12/10/3</preline>
  </pre>
</description>

<datefixed>2018-01-01</datefixed>

<references></references>

<gitfixid></gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2015-8750</cve>

<fuzzer></fuzzer>

<datereported>2015-12-26</datereported>

<reportedby>Qixue Xiao (xqx)</reportedby>

<product>libdwarf</product>

<vulnerability>  Null pointer dereference in libdwarf
</vulnerability>

<description> libdwarf 20151114 and earlier allows remote
  attackers to cause a denial of service (NULL pointer
  dereference and crash) via a debug_abbrev
  section marked NOBITS in an ELF file.
  <pre>
<preline>  bugzilla.redhat.com/show_bug.cgi?id=1294264</preline>
<preline>  www.openwall.com/lists/oss-security/2016/01/07/11</preline>
  </pre>
</description>

<datefixed>2015-12-31</datefixed>

<references> regressiontests/xqx-c/awbug6.elf
</references>

<gitfixid></gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
<dwbug>
<cve>CVE-2014-9482</cve>

<fuzzer></fuzzer>

<datereported>2014-12-31</datereported>

<reportedby>Adam Maris</reportedby>

<product>dwarfdump</product>

<vulnerability> Use after free vulnerability in Dwarfdump
</vulnerability>

<description> The use-after-free has no attached testcase
  anywhere.  Due to recent tool advances (like
  coverity scan) we are confident this was fixed long ago.
  <pre>
<preline>  bugzilla.redhat.com/show_bug.cgi?id=1177758</preline>
<preline>  www.openwall.com/lists/oss-security/2014/12/31/3</preline>
<preline>  www.openwall.com/lists/oss-security/2015/01/03/14</preline>
  </pre>
</description>

<datefixed>2018-01-01</datefixed>

<references></references>

<gitfixid></gitfixid>

<tarrelease>libdwarf-20160507.tar.gz</tarrelease>

</dwbug>
</dwarfbug>
