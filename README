
A build can be done via cmake, which is
new as of November 2016.
  mkdir /tmp/builddir
  cd /tmp/builddir
  # Assuming the source tree in /a/b/code
  cmake /a/b/code
  make

Standard builds are done by configure/make as
described below.
Cross-Compiles are described below, see
CROSS COMPILES.

BUILDING IN SOURCE TREE
To just build libdwarf and dwarfdump
if the source tree is in /a/b/libdwarf-1 
one might do:
    cd /a/b/libdwarf-1
    ./configure
    make dd
    #You may need to be root to do the following copy commands
    cp dwarfdump/dwarfdump      /usr/local/bin
    cp dwarfdump/dwarfdump.conf /usr/local/lib
    #The following is optional, not needed to run dwarfdump
    #when doing the default build.
    cp libdwarf/libdwarf.a      /usr/local/lib

BUILDING OUT OF SOURCE TREE
Or one could  create a new directory, for example,
    mkdir /var/tmp/dwarfex
    cd /var/tmp/dwarfex
    /a/b/libdwarf-1/configure
    make dd
In this case the source directory is not touched and
all objects and files created are under /var/tmp/dwarfex

NOTE: When building out of source tree the source tree
must be cleaned of any files created by a build
in the source tree. This is due to the way GNU Make
VPATH works.

For a simple build of libdwarf, and dwarfdump
and the other tools:
    ./configure
    make
    #Optionally: cp libdwarf/libdwarf.a <somewhere>

To build all the tools (including dwarfgen and 
dwarfexample) use 'make all'. There are known 
small compile-time issues with building dwarfgen on 
MaxOSX and most don't need to build dwarfgen.
    ./configure
    make all

By default configure compiles and uses libdwarf.a.

With 
    ./configure --enabled-shared
both libdwarf.a and libdwarf.so
are built. The runtimes built will reference libdwarf.so.

With 
    ./configure --enabled-shared --disable-nonshared
libdwarf.so is built and used; libdwarf.a is not built.

When ready to create a new source distribution do
    ./CPTOPUBLIC
    ./BLDLIBDWARF yyyymmdd
where that could be
    ./BLDLIBDWARF 20140131
as an example.

Sanity checking:
Recent gcc has some checks that can be done at runtime.
  -fsanitize=address
  -fsanitize=leak
  -fsanitize=undefined
which are turned on here by --enable-sanitize at build time.

CROSS-COMPILES:
For those wishing to build libdwarf (and possibly dwarfdump)
for a different machine than the build machine
it is now possible to do that.

For example, on Xubuntu 16.04 x86_64 the following works.

  git pull latest libdwarf/dwarfdump code tree.
cd code
sudo apt-get install gcc-arm-linux-gnueabihf
  [Note possible confusion in the following text, may not
  be absolutely correct. Needs work. ]
  Now ensure libelf.h libelf.a or .so is in the gcc-arm-linux-gnueabihf
  tree in the correct places. If the build machine has zlib (aka libz)
  but the arm tree does not the --disable-libz should work to
  enable building.  If the build and arm trees both have
  libelf and libz then remove the --disable-libz. 
  Neither libz nor libelf are installed automatically in
  the arm tree.

cd libdwarf 
./configure --build=i686-pc-linux-gnu --host=arm-linux-gnueabihf --disable-libz
make
cd ../dwarfdump 
./configure --build=i686-pc-linux-gnu  --host=arm-linux-gnueabihf --disable-libz
make





David Anderson.  Updated March 27, 2018
